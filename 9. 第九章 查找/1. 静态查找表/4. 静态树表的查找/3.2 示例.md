
#### 次优查找树示例

##### 例 9-1 

已知含 9 个关键字的有序表及其相应权值为：

    关键字   A  B  C  D  E  F  G  H  I
    权值     1  1  2  5  3  4  4  3  5

则按算法 9.3 构造次优査找树的过程中累计权值 SW 和△P 的值如图 $9.4(a)$ 所示，构造所得次优二叉査找树如图 $9.4(b)$ 所示。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200709162629.png)

由于在构造次优查找树的过程中，没有考察单个关键字的相应权值，则有可能出现被选为根的关键字的权值比与它相邻的关键字的权值小。此时应作适当调整：选取邻近的权值较大的关键字作次优查找树的根结点。

##### 例 9-2

已知含 5 个关键字的有序表及其相应权值为

    关键字  A   B  C   D  E 
    权值    1  30  2  29  3

则按算法 9.3 构造所得次优査找树如图 $9.5(a)$ 所示，调整处理后的次优查找树如图 $9.5(b)$ 所示。容易算得，前者的 PH 值为 132, 后者的 PH 值为 105。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200709164407.png)

大量的实验研究表明，次优査找树和最优査找树的査找性能之差仅为 1% ~ 2%，很少超过 3%，而且构造次优査找树的算法的时间复杂度为 $O(n log n)$，因此算法 9.3 是构造近似最优二叉査找树的有效算法。

从次优查找树的结构特点可见，其查找过程类似于折半查找。

$(1)$ 若次优査找树为空，则查找不成功
$(2)$ 否则，首先将给定值 key 和其根结点的关键字相比，若相等，则查找成功，该根结点的记录即为所求；
$(3)$ 否则将根据给定值 key 小于或大于根结点的关键字而分别在左子树或右子树中继续查找直至查找成功或不成功为止（算法描述和下节讨论的二叉排序树的查找算法类似，在此省略）。

由于查找过程恰是走了一条从根到待查记录所在结点（或叶子结点）的一条路径，进行过比较的关键字个数不超过树的深度，因此，次优查找树的平均查找长度和 $logn$ 成正比。可见，**在记录的查找概率不等时，可用次优查找树表示静态査找树**，故又称 **静态树表**，按有序表构造次优査找树的算法如算法 9.4 所示

###### 算法 9.4

```cpp
typedef BiTree SOSTree;                                     //次优查找树采用二叉链表的存储结构 

//由有序表 ST 构造一棵次优查找树 T。ST 的数据元素含有权域 weight
Status CreateSoStree(SOSTree & T, SSTable ST){
    if(ST.length == 0){
        T = NULL;
    }else{
        FindSW(sw, ST);                                     //按照由有序表 ST 中各数据元素的 weight 域求累计权值表 sw
        SecondOpiamal(T, ST.elem, sw, 1, ST.length);
    }
    return OK:
}//CreateSoStree
```