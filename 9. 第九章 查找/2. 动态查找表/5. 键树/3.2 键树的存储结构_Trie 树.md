
#### 键树的存储结构_Trie 树

若以树的多重链表表示键树，则树的每个结点中应含有 d 个指针域，此时的键树又称 **Trie 树**。

##### 1. Trie 树的表示

若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200714113955.png)

例如，图 9.19 所示键树中，从结点 Z 到结点 $ 为单支树，则在图 9.21 相应的 Trie 树中只有一个含有关键字 ZHAO 及相关信息的叶子结点。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200714145648.png)

由此，在 Trie 树中有两种结点：

$(1)$ 分支结点（含有 d 个指针域和一个指示该结点中非空指针域的个数的整数域）
$(2)$ 叶子结点（含有关键字域和指向记录的指针域）

在分支结点中不设数据域，每个分支结点所表示的字符均由其双亲结点中（指向该结点）的指针所在位置决定。

##### 2. Trie 树的查找过程

在 Trie 树上进行查找的过程为：

1. 从根结点出发，沿和给定值相应的指针逐层向下，直至叶子结点，若叶子结点中的关键字和给定值相等，则查找成功;
2. 若分支结点中和给定值相应的指针为空，或叶结点中的关键字和给定值不相等，则査找不成功。

##### 3. 实例代码

若设键树类型如下:

```cpp
typedef struct TrieNode{
    NodeKind kind;
    union{
        struct{
            KeysType Record * inforptr; 
        }lf;                                   //叶子结点
        struct{ 
            TrieNode * ptr[27]; 
            int num; 
        }bh;                                   //分支结点
    };
}TrieNode, * TrieTree;                         //键树类型
```

则键树查找操作可如算法 9.16 实现之。

###### 算法 9.16

```cpp
Record * SearchTrie(TrieTree T, KeysType K){

    //在键树中査找关键字等于 K 的记录。
    for(p = T, i = 0;                          //对 K 的每个字符逐个査找
        p && p -> kind == BRANCH && i < K.num; // *p 为分支结点
        p = p -> bh.ptr[ord(K.ch[i])], ++i);   //ord 求字符在字母表中序号   //假设 ord 过程将 K.ch [i 门字符转换成该字符在字母表中序号，并假设字符'S'的序号为零。

    if (p && p -> kind == LEAR && p -> lf.K == K) 
        return p -> lf.infoptr;                //查找成功
    else 
        return NULL;                           //查找不成功 
        
}//SearchTrie
```

从上述查找过程可见，在查找成功时走了一条从根到叶子结点的路径。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200714145648.png)

例如，在图 9.21 上，查找关键字 CHEN 的过程为：从根结点 $\alpha$ 出发，经 $\beta$、$\gamma$ 结点，最后到达叶子结点 $\delta$。而查找 CHAI 的过程为从根结点 $\alpha$ 出发，经 $\beta$、$\gamma$ 结点后到 $\epsilon$ 结点。由于该结点中和字符 'T' 相应的指针为空，则查找不成功。由此，其查找的时间依赖于树的深度。

我们可以对关键字集选择一种合适的分割，以缩减 Trie 树的深度。例如，根据（9-24) 中关键字集的特点，可作如下分割:

1. 先按首字符不同分成多个子集之后。
2. 然后按最后一个字符不同分割每个子集，再按第二个字符 $\cdots$，前后交叉分割。

由此得到如图 9.22 所示的 Trie 树，在该树上，除两个叶子结点在第四层上外，其余叶子结点均在第三层上。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200714152458.png)

还可限制 Trie 树的深度，假设允许 Trie 树的最大深度为 l，则所有直至 l - 1 层皆为同义词的关键字都进人同一叶子结点。若分割得合适，则可使每个叶子结点中只含有少数几个同义词。当然也可增加分支的个数以减少树的深度。

在 Trie 树上易于进行插入和删除，只是需要相应地增加和删除一些分支结点。当分支结点中 num 域的值减为 1 时，便可被删除。

##### 4. 双链树 和 Trie 树的比较

双链树和 Trie 树是键树的两种不同的表示方法，它们有各自的特点。从其不同的存储结构特性可见，若键树中结点的度较大，则采用 Trie 树结构较双链树更为合适。

综上对树表的讨论可见，它们的查找过程都是从根结点出发，走了一条从根到叶子（或非终端结点）的路径，其查找时间依赖于树的深度。由于树表主要用作文件索引，因此结点的存取还涉及外部存储设备的特性，故在此没有对它们作平均查找长度的分析。
