
#### 二叉排序树的删除

同样，在二叉排序树上删去一个结点也很方便。对于一般的二叉树来说，删去树中个结点是没有意义的。因为它将使以被删结点为根的子树成为森林，破坏了整棵树的结构。然而，对于二叉排序树，删去树上一个结点相当于删去有序序列中的一个记录，只要在删除某个结点之后依旧保持二叉排序树的特性即可。

##### 1. 二叉排序树的删除过程

那么，如何在二叉排序树上删去一个结点呢？假设在二叉排序树上被删结点为 `*p`（ 指向结点的指针为 p），其双亲结点为 `*I` 结点指针为 f ），且不失一般性，可设 `*p` 是 `*f` 的左孩子（图 9.9 (a）所示）。

> 以下均简称指针 p（或 f 等）所指结点为 `*p`（或 `*f` 等）结点，$P_L$ 和 $P_R$ 分别表示其左子树和右子树。

下面分 3 种情况进行讨论：

$(1)$ 若 `*p` 结点为叶子结点，即 $P_L$ 和 $P_R$ 均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
$(2)$ 若 `*p` 结点只有左子树 $P_L$ 或者只有右子树 $P_R$，此时只要令 $P_L$ 或 $P_R$ 直接成为其双亲结点 `*f` 的左子树即可。显然，作此修改也不破坏二叉排序树的特性
$(3)$ 若 `*p` 结点的左子树和右子树均不空。显然，此时不能如上简单处理。

从图 $9.9 (b)$ 可知，在删去 `*p` 结点之前，中序遍历该二叉树得到的序列为 $\left\{\cdots C_{L} C \cdots Q_{L} Q S_{L} S P P_{R} F \cdots\right\}$ 在删去 `*p` 之后，为保持其他元素之间的相对位置不变，可以有两种做法：

1. 其一是令 `*p` 的左子树为 `*f` 的左子树，而 `*p` 的右子树为 `*s` 的右子树，如图 9.9 (c）所示；
2. 其二是令 `*p` 的直接前驱（或直接后继）替代 `*p`，然后再从二叉排序树中删去它的直接前驱（或直接后继）。如图 9.9 (d）所示，当以 `*p` 的直接前驱 `*s` 替代 `*p` 时，由于 `*s` 只有左子树 $S_L$，则在去 `*s` 之后，只要令 $S_L$ 为 `*s` 的双亲 `*q` 的右子树即可。

> `*p` 的直接前驱就是 `*s`，`*s` 比它左边的左右数都大，但是比 `*p` 小，所以可以让 `*s` 代替 `*p`，而 `*s` 的左节点比 `*s` 左边除了左节点外的数都大，所以移除 `*s` 后可以做为 `*s` 的双亲结点 `*q` 的右子树

![](https://gitee.com/mayundaze/img_bed/raw/master/20200710135657.png)

在二叉排序树上删除一个结点的算法如算法 9.7 所示，其中由前述 3 种情况综合所得的删除操作如算法 9.8 所示。

###### 算法 9.7

```cpp
//若二叉排序树中存在关键字等于 key 的数据元素时，则删除该数据元素结点，并返回 TRUE；否则返回 FALSE
Status DeleteBST(Bitree &T, KeyType key){
    if(!T) 
        return FALSE;                                   //不存在关键字等于 key 的数据元素
    else{
        if(EQ(key, T -> data.key) { 
            return Delete (T);                          //找到关键字等于 key 的数据元素
        }else if(LT(key, T -> data.key)){
            return DeleteBST(T -> lchild, key);
        }else 
            return DeleteBST(T -> rchild, key);
    }
}// DeleteBST
```

###### 算法 9.8

```cpp
//从二叉排序树中删除结点 P，并重接它的左或右子树 
Status Delete (Bitree & p){
    
    if (!p -> rchild){                                  //右子树空则只需重接它的左子树 
        
        q = p; 
        p = p -> lchild;
        free(q);

    }else if (!p -> lchild){                            //只需重接它的右子树

        q = p; 
        p = p -> rchild; 
        free(q);

    else{                                               //左右子树均不空
        
        q = p; 
        s = p -> lchild;

        while (s -> rchild) {                           //转左，然后向右到尽头，即找到 p 的左结点的最右边(直接前驱)
            q = s; 
            s = s -> rchild
        }                                               
        
        p -> data = s -> data;                          //s 指向被删结点的“前驱”

        if( q != p)                                     //如果 p 的左节点 s 有右节点
            q -> rchild = s -> lchild;                  //重接 *q 的右子树 
        else                                            //如果 p 的左节点 s 没有右节点
            q -> lchild = s -> lchild;                  //重接 *q 的左子树 

        delete s;
    }
    return TRUE
}// Delete
```
