
#### B- 树的查找

由 B- 树的定义可知，在 B- 树上进行查找的过程和二叉排序树的查找类似。

##### 1. 查找过程

###### B- 树查找关键字成功的过程

例如，在图 9.14 的 B- 树上查找关键字 47 的过程如下：

$(1)$ 首先从根开始，根据根结点指针 t 找到 *a 结点，因 *a 结点中只有一个关键字，且给定值 47 > 关键字 35, 则若存在必在指针 $A_1$ 所指的子树内。
$(2)$ 顺指针找到 *c 结点，该结点有两个关键字（43 和 78），而 43 < 47 < 78, 则若存在必在指针 $A_1$ 所指的子树中。
$(3)$ 同样，顺指针找到 *g 结点，在该结点中顺序查找找到关键字 47, 由此，查找成功

###### B- 树查找关键字不成功的过程

查找不成功的过程也类似，例如在同一棵树中査找 23 过程如下:

$(1)$ 从根开始，因为 23 < 35, 则顺该结点中指针 $A_0$ 找到 *b 结点。
$(2)$ 又因为 *b 结点中只有一个关键字 18, 且 23 > 18, 所以顺结点中第二个指针 A1 找到 *e 结点。
$(3)$ 同理因为 23 <27, 则顺指针往下找，此时因指针所指为叶子结点，说明此棵 B 树中不存在关键字 23, 查找因失败而告终。

由此可见，在 B- 树上进行查找的过程是一个顺指针査找结点和在结点的关键字中进行查找交叉进行的过程。

##### 2. B- 树的结点类型

由于 B- 树主要用作文件的索引，因此它的查找涉及外存的存取，在此略去外存的读写，只作示意性的描述。假设结点类型如下说明：

```cpp
#define m 3                            //B- 树的阶，暂设为 3 

typedef struct BTNode{

    int keynum;                        //结点中关键字个数，即结点的大小
    struct BTNode * parent;            //指向双亲结点

    KeyType key[m + 1];                //关键字向量，0 号单元未用
    struct BTNode * ptr[m + 1];        //子树指针向量

    Record * recptr[m + 1];            //记录指针向量，0 号单元未用 

}BTNode, * BTree;                      //B 树结点和 B-树的类型 

typedef struct{

    BTNode * pt;                       //指向找到的结点
    int i;                             //1..M，在结点中的关键字序号 
    int tag;                           //1: 查找成功，0: 查找失败

}Result;                               //B- 树的查找结果类型
```

##### 3. B- 树查找的代码实现

则算法 9.13 简要地描述了 B- 树的査找操作的实现。

###### 算法 9.13

```cpp
//在 m 阶 B- 树 T 上査找关键字 K，返回结果（pt, i, tag）。
//若査找成功，则特征值 tag=1, 指针 pt 所指结点中第 i 个关键字等于 K；
//否则特征值 tag=0, 等于 K 的关键字应插入在指针 pt 所指结点中第 i 和第 i + 1 个关键字之间

Result SearchBTree (BTree T, KeyType K){

    p = T; 
    q = NUILL; 
    found = FALSE;
    i = 0;                              //初始化，p 指向待查结点，q 指向 p 的双亲 
    
    while(p && !found){
        i = Search (p, K);              //在 p -> key[1.. keynum] 中査找，i 使得：pー> key[i] <= K < p -> key[i + 1] 
        if(i > 0 && p -> key[i] = K){
            found = TRUE;               //找到待查关键字 
        }else{
            q = p; p = p -> ptr[i];
        }
    }

    if(found) 
        return(p, i, 1);                //査找成功
    else 
        return(a, i, 0);                //査找不成功，返回 K 的插入位置信息 
}// SearchBTree
```
