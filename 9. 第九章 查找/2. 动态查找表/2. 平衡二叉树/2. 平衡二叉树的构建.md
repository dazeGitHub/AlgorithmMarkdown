
#### 平衡二叉树的构建

如何使构成的二叉排序树成为平衡树呢？

##### 1. 构建示例

先看一个具体例子（参见图 9.12)。假设表中关键字序列为（13,24,37,90,53)。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200710170032.png)

1. 空树和 1 个结点 $(13)$ 的树显然都是平衡的二叉树。
2. 在插入 24 之后仍是平衡的，只是根结点的平衡因子 BF 由 0 变为 $-1$; 
3. 再继续插入 37 之后，由于结点 $(13)$ 的 BF 值由 -1 变成 -2, 由此出现了不平衡的现象。此时好比一根扁担出现一头重一头轻的现象，若能将扁担的支撑点由 $(13)$ 改至 $(24)$，扁担的两头就平衡了。由此，可以对树作一个向左逆时针“旋转”的操作，令结点 $(24)$ 为根，而结点 $(13)$ 为它的左子树，此时，结点 $(13)$ 和 $(24)$ 的平衡因子都为 0, 而且仍保持二叉排序树的特性。
4. 再继续插入 90 和 53 之后，由于结点 $(37)$ 的 BF 值由 -1 变成一 2, 排序树中出现了新的不平衡的现象，需进行调整。但此时由于结点 $(53)$ 插在结点 $(90)$ 的左子树上，因此不能如上作简单调整。对于以结点 $(37)$ 为根的子树来说，既要保持二叉排序树的特性，又要平衡，则必须以 $(53)$ 作为根结点，而使 $(37)$ 成为它的左子树的根，$(90)$ 成为它的右子树的根。

这好比对树作了两次“旋转”操作 一 先向右顺时针，后向左逆时针（见图 $9.12(f) - (h)$），使二叉排序树由不平衡转化为平衡。

##### 2. 构建步骤

一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指针为 a（即 a 是离插入结点最近，且平衡因子绝对值超过 1 的祖先结点），则失去平衡后进行调整的规律可归纳为下列 4 种情况：

$(1)$ 单向右旋平衡处理：由于在 `*a` 的左子树根结点的左子树上插入结点，`*a` 的平衡因子由 1 增至 2, 致使以`*a` 为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如图 9.13 (a）所示。
$(2)$ 单向左旋平衡处理：由于在`*a` 的右子树根结点的右子树上插人结点，`*a` 的平衡因子由 - 1 变为一 2, 致使以`*a` 为根结点的子树失去平衡，则需进行一次向左的逆时针旋转操作。如图 9.13 (c）所示。
$(3)$ 双向旋转（先左后右）平衡处理：由于在`*a` 的左子树根结点的右子树上插入结点，a 的平衡因子由 1 增至 2, 致使以`*a` 为根结点的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。如图 9.13 (b）所示。
$(4)$ 双向旋转（先右后左）平衡处理：由于在`*a` 的右子树根结点的左子树上插入结点，`*a` 的平衡因子由一 1 变为一 2, 致使以`*a` 为根结点的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。如图 9.13 (d）所示。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200710173542.png)

上述 4 种情况中，$(1)$ 和 $(2)$ 对称，$(3)$ 和 $(4)$ 对称。

旋转操作的正确性容易由 “保持二叉排序树的特性：中序遍历所得关键字序列自小至大有序” 证明之。同时，从图 9.13 可见，无论哪一种情况，在经过平衡旋转处理之后，以 `*b` 或 `*c` 为根的新子树为平衡二叉树，而且它的深度和插入之前以 `*a` 为根的子树相同。因此，当平衡的二叉排序树因插入结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。因为经过旋转处理之后的子树深度和插入之前相同，因而不影响插入路径上所有祖先结点的平衡度。

##### 3. 算法描述

在平衡的二叉排序树 BBST 上插入一个新的数据元素 e 的递归算法可描述如下：

$(1)$ 若 BBST 为空树，则插入一个数据元素为 e 的新结点作为 BBST 的根结点，树的深度增 1;
$(2)$ 若 e 的关键字和 BBST 的根结点的关键字相等，则不进行插入；
$(3)$ 若 e 的关键字小于 BBST 的根结点的关键字，而且在 BBST 的左子树中不存在和 e 有相同关键字的结点，则将 e 插入在 BBST 的左子树上，并且当插入之后的左子树深度增加（+ 1) 时，分别就下列不同情况处理之：

* BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：则将根结点的平衡因子更改为 0, BBST 的深度不变；
* BBST 的根结点的平衡因子为 0（左、右子树的深度相等）：则将根结点的平衡因子更改为 1, BBST 的深度增 1;
* BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：若 BBST 的左子树根结点的平衡因子为 1, 则需进行单向右旋平衡处理，并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为 0, 树的深度不变；
若 BBST 的左子树根结点的平衡因子为一 1, 则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后，修改根结点和其左、右子树根结点的平衡因子，树的深度不变；

$(4)$ 若 e 的关键字大于 BBST 的根结点的关键字，而且在 BBST 的右子树中不存在和 e 有相同关键字的结点，则将 e 插入在 BBST 的右子树上，并且当插入之后的右子树深度增加（+1) 时，分别就不同情况处理之。其处理操作和（三）中所述相对称，读者可自行补充。

算法 9.9 和算法 9.10 分别描述了在平衡处理中进行右旋操作和左旋操作时修改指针的情况。右平衡处理的算法和左平衡处理的算法类似，读者可自己补充。

二叉排序树的类型定义为:

```cpp
typedef struct BSTNode{
    ElemType data;
    int bf;                                        //结点的平衡因子 
    struct BSTNode * lchild, * rchild;             //左、右孩子指针 
}BSTNode, * BSTree;
```

###### 算法 9.9（LL）

```cpp
//对以 *p 为根的二叉排序树作右旋处理，处理之后 p 指向新的树根结点，即旋转处理之前的左子树的根结点 
void R_Rotate(BSTree &p){
    
    lc = p -> lchild;                              //lc 指向的 *p 的左子树根结点 
    p -> lchild = lc -> rchild;                    //lc 的右子树挂接为 *p 的左子树 
    lc -> rchild = p; 
    p = lc;                                        //p 指向新的根结点 

}//R_Rotate
```

###### 算法 9.10（RR)

```cpp
void L_Rotate(BSTree &p){
    //对以 *p 为根的二叉排序树作左旋处理，处理之后 p 指向新的树根结点，即旋转处理之前的右子树的根结点
    rc = p -> rchild;                                  //rc 指向的 *p 的右子树根结点 
    p -> rchild = rc -> lchild;                        //rc 的左子树挂接为 *p 的右子树 
    rc -> lchild = p; 
    p = rc;                                            //p 指向新的根结点 
}//L_Rotate
```

假设在 “6.2.3 二叉树的存储结构” 中定义的二叉链表的结点中增加一个存储结点平衡因子的域 bf，则上述在平衡的二叉排序树 BST 上插入一个新的数据元素 e 的递归算法如算法 9.11 所示，其中，左平衡处理的算法如算法 9.12 所示。

###### 算法 9.11

```cpp
# define LH  +1                                        //左高
#define  EH  0                                         //等高
#define  RH  -1                                        //右高

//若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点，则插人一个数据元素为 e 的新结点，并返回 1, 否则返回 0。
//若因插人而使二叉排序树失去平衡，则作平衡旋转处理，布尔变量 taller 反映 T 长高与否 
Status InsertAVL(BSTree &T, ElemType e, Boolean & taller){
    if (!T) {                                          //插入新结点，树“长高”，置 taller 为 TRUE
        T = (BSTree) malloc(sizeof(BSTNode)): 
        T -> data = e;
        T -> lchild = T -> rchild = NULL; 
        T -> bf = EH; 
        taller = TRUE;
    }else{
        if(EQ(e.key, T -> data.key)){                  //树中已存在和 e 有相同关键字的结点
            taller = FALSE; 
            return 0; 
        }                                              //则不再插人
        if(LT(e.key,T -> data.key)){                   //应继续在 *T 的左子树中进行搜素
            if (!InsertAVL(T -> lchild, e, taller))
                return 0;                              //未插入
            if(taller)                                 //已插入到*T 的左子树中且左子树“长高”
                switch(T -> bf){                       //检查 *T 的平衡度
                    case LH:                           //原本左子树比右子树高，需要作左平衡处理
                        LeftBalance(T); 
                        taller = FALSE; 
                    break;
                    case EH:                           //原本左、右子树等高，现因左子树增高而使树增高
                        T -> bf = LH; 
                        taller = TRUE; 
                    break;
                    case RH:                           //原本右子树比左子树高，现左、右子树等高
                        T -> bf = EH; 
                        taller = FALSE; 
                        break;
                }// switch (T -> bf)
        }//if
        else{                                           //应继续在 *T 的右子树中进行拽索
            if (!InsertAVL(T -> rchild, e, taller)) 
                return 0;                               //未插人
            if (taller)                                 //已插入到 *T 的右子树且右子树长高
                switch (T -> bf){                       //检查 *T 的平衡度
                    case LH:                            //原本左子树比右子树高，现左、右子树等高
                        T -> bf = EH; 
                        taller = FALSE; 
                        break;
                    case EH:                            //原本左、右子树等高，现因右子树增高而使树增高
                        T -> bf = RH; 
                        taller = TRUE; 
                        break;
                    case RH:                            //原本右子树比左子树高，需要作右平衡处理
                        RightBalance(T); 
                        taller = EALSE; 
                        break;
                }// switch (T-> bf)
        }//else
    }//else
    return 1
}// InsertAVL
```

###### 算法 9.12

```cpp
//对以指针 T 所指结点为根的二叉树作左平衡旋转处理，本算法结束时，指针 T 指向新的根结点
void LeftBalance(BSTree & T){

    lc = T -> lchild;                                   //lc 指向 *T 的左子树根结点 
    
    switch (lc -> bf){                                  //检查 *T 的左子树的平衡度，并作相应平衡处理

        case LH:                                        //新结点插入在 *T 的左孩子的左子树上，要作单右旋处理
            T -> bf = lc -> bf = EH;
            R_Rotate(T); 
            break;

        case RH:                                        //新结点插入在 *T 的左孩子的右子树上，要作双旋处理
            rd = lc -> rchild;                          //rd 指向 *T 的左孩子的右子树根
            switch (rd -> bf){                          //修改 *T 及其左孩子的平衡因子
                case LH:
                    T -> bf = RH; 
                    lc -> bf = EH; 
                    break; 
                case EH: 
                    T -> bf = lc -> bf = EH;
                case RH: 
                    T -> bf = EH; 
                    lc -> bf = LH; 
                break; 
            }// switch (rd -> bf)

            rd -> bf = EH;
            L_Rotate(T -> lchild);                      //对 *T 的左子树作左旋平衡处理 
            R_Rotate(T);                                //对 *T 作右旋平衡处理 

    }// switch(lc -> bf) 
}// eftbalance
```