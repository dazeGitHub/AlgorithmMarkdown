
#### 表达式求值

表达式求值是程序设计语言编译中的一个最基本问题。它的实现是栈应用的又一个典型例子。这里介绍一种简单直观、广为使用的算法，通常称为 **"算符优先法"**

要把一个表达式翻译成正确求值的一个机器指令序列，或者直接对表达式求值，首先要能够正确解释表达式。例如，要对下面的算术表达式求值：

$\qquad 4 + 2 × 3 - 10 / 5$

首先要了解算术四则运算的规则。即：

(1) 先乘除，后加减； 
(2) 从左算到右； 
(3) 先括号内，后括号外

由此，这个算术表达式的计算顺序应为

$\qquad 4 + 2 × 3 - 10 / 5 = 4 + 6 - 10 / 5 = 10 - 10 / 5 = 8$

算符优先法就是根据这个运算优先关系的规定来实现对表达式的编译或解释执行的。

任何一个表达式都是由 `操作数（operand）`、`运算符（operator）` 和 `界限符（delimiter）` 组成的，我们称它们为单词。一般地，操作数既可以是常数也可以是被说明为变量或常量的标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符 3 类；基本界限符有 左右括号 和 表达式结束符 等

为了叙述的简洁，我们仅讨论简单算术表达式的求值问题。这种表达式只含加、减、乘、除 4 种运算符。读者不难将它推广到更一般的表达式上。

我们把 运算符 和 界限符 统称为算符，它们构成的集合命名为 OP。根据上述 3 条运算规则，在运算的每一步中，任意两个相继出现的算符 $\theta_1$ 和 $\theta_2$ 之间的优先关系至多是下面 3 种关系之一:

$\qquad \theta_1 < \theta_2 \qquad$ $\theta_1$ 的优先权低于 $\theta_2$
$\qquad \theta_{1} = \theta_{2} \qquad$ $\theta_1$ 的优先权等于 $\theta_2$
$\qquad \theta_{1} > \theta_{2} \qquad$ $\theta_1$ 的优先权高于 $\theta_2$

表 3.1 定义了算符之间的这种优先关系。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200617104652.png)

##### 表格解析

由规则(3)，+、一、* 和 / 为 $\theta_1$ 时的优先性均低于 "(" 但高于 ")"，由规则(2),当 $\theta_1 = \theta_2$ 时，令 $\theta_1 > \theta_2$，"#"是表达式的结束符。

为了算法简洁，在表达式的最左边也虚设一个"#"构成整个表达式的一对括号。表中的 "(" = ")" 表示当左右括号相遇时，括号内的运算已经完成。同理，"#"="#" 表示整个表达式求值完毕。")"与"("、"#" 与 ")" 以及 "(" 与 "#" 之间无优先关系，这是因为表达式中不允许它们相继出现，一旦遇到这种情况，则可以认为出现了语法错误。在下面的讨论中，我们暂假定所输入的表达式不会出现语法错误。

为实现算符优先算法，可以使用两个工作栈。一个称做 **OPTR**，用以寄存运算符；另一个称做 **OPND**，用以寄存操作数或运算结果。算法的基本思想是：

> Operator:运算符，简称 `OPTR`    Operands:操作数，简称 `OPND`

 (1) 首先置操作数栈为空栈，表达式起始符“#”为运算符栈的栈底元素；
 (2) 依次读入表达式中每个字符，若是操作数则进 OPND 栈，若是运算符则和 OPTR 栈的栈顶运算符比较优先权后作相应操作，直至整个表达式求值完毕（即 OPTR 栈的栈顶元素和当前读入的字符均为“#”）

算法 3.4 描述了这个求值过程。

###### 算法 3.4

```cpp
//计算表达式的值
//每次输入都会比较运算符栈 OPIR 顶部元素 和 输入的运算符的优先级，如果运算符栈 OPIR 顶部元素是优先级高的(例如乘除法)，则先进行乘除法运算，该运算符栈 OPIR 出栈 Pop
//当输入右括号 ) 时，运算符栈 OPIR 顶部操作符除了 # 和 ( 优先级都比右括号 ) 高，所以先会算括号内的，直到整个括号算完
//当表达式都为同一优先级的运算符(+ 或 -)时，遇到输入字符为 # 号后开始取运算数栈 OPND 顶部的两个操作数运算，此时输入字符 c 还是 # 号，所以一直循环直到 运算符栈 OPIR 栈顶元素和当前读入的字符均为 #
OperandType EvaluateExpression() {

    //算术表达式求值的算符优先算法
    //设 OPIR 和 OPND 分别为运算符栈 和 运算数栈，OP 为运算符集合

    SqStack OPTR;
    SqStack OPND;

    InitStack(OPTR);
    Push(OPTR, '#');
    InitStack(OPND);

    printf("请输入运算表达式中的字符: ");
//    char c = getchar();
    char c;
    scanf(" %c",&c) ;

    while (c != '#' || GetTop(OPTR) != '#') {       //当满足条件 (c == '#' && GetTop(OPTR) == '#') 时退出循环

//        if (!In(c, OP)) {                         //不是运算符
        if (!In(c)) {
            Push(OPND, c);                          //则进入 运算数栈 OPND
            printf("请输入运算表达式中的字符: ");
//          c = getchar();
            scanf(" %c",&c) ;                       //%c 前面加空格防止输入空白字符
        } else {                                    //是运算符
            switch (Precede(GetTop(OPTR), c)) {     //判断 运算符栈 OPTR 顶部元素 和运算符 c 的优先级
                case '<':                           //运算符栈 OPTR 顶部元素优先权低
                    Push(OPTR, c);
                    printf("请输入运算表达式中的字符: ");
//                  c = getchar();
                    scanf(" %c",&c) ;
                    break;

                case '=':                           //脱括号并接收下一字符 (只有括号的优先级是相等的)
                    SElemType x;
                    Pop(OPTR, x);
                    printf("请输入运算表达式中的字符: ");
//                  c = getchar();
                    scanf(" %c",&c) ;
                    break;

                case '>':                           //运算符栈 OPTR 顶部元素优先级高，退栈并将运算结果入栈
                    SElemType theta;
                    Pop(OPTR, theta);

                    SElemType b;
                    Pop(OPND, b);

                    SElemType a;
                    Pop(OPND, a);

                    Push(OPND, Operate(a, theta, b));
                    break;
            }// switch
        }
    }// while

    return GetTop(OPND);
}//EvaluateExpression
```

算法中还调用了两个函数。其中 Precede 是判定运算符栈的栈顶运算符 $\theta_1$ 与读入的运算符 $\theta_2$ 之间优先关系的函数; Operate 为进行二元运算 $a \theta b$ 的函数，如果是编译表达式，则产生这个运算的一组相应指令并返回存放结果的中间变量名；如果是解释执行表达式，则直接进行该运算，并返回运算的结果。

完整代码见: `TestAlgorithm` 项目的 `stack_use5_expression.cpp`

##### 例 3-1 

利用算法 EvaluateExpression-reduced 对算术表达式 $3 * (7-2)$ 求值，操作过程如下所示。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200617141600.png)
