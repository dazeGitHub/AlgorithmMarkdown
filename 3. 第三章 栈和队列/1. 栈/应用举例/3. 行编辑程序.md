
#### 行编辑程序

一个简单的行编辑程序的功能是：接受用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输人时，不能保证不出差错，因此，若在编辑程序中，“每接受一个字符即存入用户数据区”的做法显然不是最恰当的。较好的做法是，设立一个输入缓冲区，用以接受用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。

例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符“#”，以表示前一个字符无效；如果发现当前键入的行内差错较多或难以补救，则可以键入一个退行符“@”，以表示当前行中的字符均无效。

##### 示例

例如，假设从终端接受了这样两行字符：

```cpp
whli ## ilr # e(s # * s)
    outcha@putchar ( * s = # ++);
```

则实际有效的是下列两行：

```cpp
while  (*s)
    putchar (* s++);
```

为此，可设这个输入缓冲区为一个栈结构，每当从终端接受了一个字符之后先作如下判别：

1. 如果它既不是退格符也不是退行符，则将该字符压入栈顶；
2. 如果是一个退格符，则从栈顶删去ー个字符；
3. 如果它是一个退行符，则将字符栈清为空栈。

上述处理过程可用算法 3.2 描述:

###### 算法 3.2

```cpp
void LineEdit() {

    SqStack stack;
    //利用字符栈 S，从终端接收一行并传送至调用过程的数据区。
    InitStack(stack);                                       //构造空栈 S
    int ch = getchar();                                     //从终端接收第一个字符

    while (ch != EOF) {                                     //EOF 为全文结束符
        while (ch != EOF && ch != '\n') {
            switch (ch) {
                case '#':
                    Pop(stack, ch);                         //仅当栈非空时退栈
                    break;

                case '@':
                    ClearStack(stack);                      //重置 S 为空
                    break;

                default:
                    Push(stack, ch);
                    break;                                  //有效字符进栈，未考虑栈满情形
            }
            ch = getchar();                                 //从终端接收下一个字符
        }

        //伪代码: 将从栈底到栈顶的栈内字符传送至调用过程的数据区；

        ClearStack(stack);                                  //重置 S 为空栈

        if (ch != EOF)
            ch = getchar();

        DestroyStack(stack);
    }
}// LineEdit
```