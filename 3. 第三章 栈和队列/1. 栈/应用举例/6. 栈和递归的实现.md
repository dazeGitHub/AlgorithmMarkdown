
#### 栈和递归的实现

栈还有一个重要应用是在程序设计语言中实现递归。一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做 **递归函数**

递归是程序设计中一个强有力的工具。

其一，有很多数学函数是递归定义的，如大家熟悉的阶乘函数

$\qquad\operatorname{Fact}(n)=\left\{\begin{array}{ll}1 & \text { 若 } n=0 \\ n \cdot \operatorname{Fact}(n-1) & \text { 若 } n>0\end{array}\right. \qquad\qquad\qquad\qquad\quad (3-1)$

2 阶 Fibonacci 数列

$\qquad\operatorname{Fib}(n)=\left\{\begin{array}{ll}0 & \text { 若 } n=0 \\ 1 & \text { 若 } n=1 \\ \text { Fib }(n-1)+\operatorname{Fib}(n-2) & \text { 其他情形 }\end{array}\right. \qquad\qquad\; (3-2)$

和 Ackerman 函数等；

$\qquad\operatorname{Ack}(m, n)=\left\{\begin{array}{ll}n+1 & \text { 若 } m=0 \\ \operatorname{Ack}(m-1,1) & \text { 若 } n=0 \\ \operatorname{Ack}(m-1, \operatorname{Ack}(m, n-1)) & \text { 其他情形 }\end{array}\right. \qquad (3-3)$

其二，有的数据结构，如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述；

其三，还有一类问题，虽然问题本身没有明显的递归结构，但用递归求解比迭代求解更简单，如 八皇后问题、Hanoi塔问题等。

##### 1. 例 3-2 (m 阶 Hanoi 塔问题）

假设有 3 个分别命名为 X、Y 和 Z 的塔座，在塔座 X 上插有 n 个直径大小各不相同、依小到大编号为 1,2, …, n 的圆盘（如图 3.5 所示）。

现要求将 X 轴上的 n 个圆盘移至塔座 Z 上并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：

(1) 每次只能移动一个圆盘；
(2) 圆盘可以插在 X、Y 和 Z 中的任一塔座上； 
(3) 任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。

如何实现移动圆盘的操作呢？

1. 当 n = 1 时，问题比较简单，只要将编号为 1 的圆盘从塔座 X 直接移至塔座 Z 上即可；
2. 当 n > 1 时，需利用塔座 Y 作辅助塔座，若能设法将压在编号为 n 的圆盘之上的 nー1 个圆盘从塔座 X（依照上述法则）移至塔座 Y 上，则可先将编号为 n 的圆盘从塔座 X 移至塔座 Z 上，然后再将塔座 Y 上的 n-1 个圆盘（依照上述法则）移至塔座 Z 上。而如何将 nー1 个圆盘从一个塔座移至另一个塔座的问题是一个和原问题具有相同特征属性的问题，只是问题的规模小 1, 因此可以用同样的方法求解。

由此可得如算法 3.5 所示的求解 n 阶 Hanoi 塔向题的 C 函数

###### 算法 3.5

```cpp
int move_count = 0;

void move(char from, int num, char to) {
    ++move_count;
    printf("将编号为 %d 的圆盘从 %c 移到 %c , 第 %d 次移动 \n", num, from, to, move_count);
}

// 将塔座 x 上按直径由小到大且自上而下编号为 1 至 n 的 n 个圆盘按规则搬到塔座 z 上，y 用作辅助塔座
//这里在函数语句前面添加行号表示返回地址，具体见 "3. 递归函数的调用过程"
void hanoi(int n, char x, char y, char z) 
    // 搬动操作 move (x, n, z）可定义为（c 是初值为 0 的全局变量，对搬动计数）
    // printf ("%i, Move disk %i from %c to %c \n", ++c, n, x, z);
1  {
2     if (n == 1)
3        move(x, 1, z);                  //将编号为 1 的圆盘从 x 移到 z
4     else {
5       hanoi(n - 1, x, z, y);          //将 x 上编号为 1 至 n - 1 的圆盘移到 y, z 作辅助塔
6       move(x, n, z);                  //将编号为 n 的圆盘从 x 移到 z
7       hanoi(n - 1, y, x, z);          //将 y 上编号为 1 至 n - 1 的圆盘移到 z, x 作辅助塔
8     }
9  }
```

显然，这是一个递归函数，在函数的执行函数中，需多次进行自我调用。那么，这个递归函数是如何执行的？先看任意两个函数之间进行调用的情形。

##### 2. 两个函数之间的调用过程

与汇编程序设计中主程序和子程序之间的链接及信息交换相类似，在高级语言编制的程序中，调用函数和被调用函数之间的链接及信息交换需通过栈来进行。

> 若在函数 A 中调用了函数 B，则称函数 A 为调用函数，称函数 B 为被调用函数。

通常，当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成 3 件事：
$\quad(1)$ 将所有的实在参数、返回地址等信息传递给被调用函数保存；
$\quad(2)$ 为被调用函数的局部变量分配存储区；
$\quad(3)$ 将控制转移到被调函数的入口。

而从被调用函数返回调用函数之前，系统也应完成 3 件工作：
$\quad(1)$ 保存被调函数的计算结果；
$\quad(2)$ 释放被调函数的数据区；
$\quad(3)$ 依照被调函数保存的返回地址将控制转移到调用函数。

当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶。

例如，在图 3.6 (c）所示主函数 main 中调用了函数 first，而在函数 first 中又调用了函数 second，则图 3.6 (a）展示了当前正在执行函数 second 中某个语句时栈的状态，而图 3.6 (b）展示从函数 second 退出之后正执行函数 first 中某个语句时栈的状态（图中以语句标号表示返回地址）

![](https://gitee.com/mayundaze/img_bed/raw/master/20200617161152.png)

##### 3. 递归函数的调用过程

一个递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数，因此，和每次调用相关的一个重要的概念是递归函数运行的 **“层次”**。假设调用该递归函数的主函数为第 0 层，则从主函数调用递归函数为进人第 1 层；从第 i 层递归调用本函数为进入“下一层”，即第 i + 1 层。反之，退出第 i 层递归应返回至“上一层”，即第 i - 1 层。

为了保证递归函数正确执行，系统需设立一个“递归工作栈” 作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“工作记录”，其中包括所有的实在参数、所有的局部变量以及上一层的返回地址。每进入一层递归，就产生个新的工作记录压入栈顶。每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为 **“活动记录”**，并称指示活动记录的栈顶指针为 **“当前环境指针”**

> 在实际的系统中，一般都综合考虑递归调用和非递归调用统一处理，在此，我们只讨论直接递归调用的处理机制。

例如，图 3.7 展示了语句

$Hanoi (3, a, b, c) \qquad (3-4)$

的执行过程（从主函数进入递归函数到退出递归函数而返回至主函数）中递归工作栈状态的变化情况。由于算法 3.5 所示的递归函数中只含 4 个值参数，则每个工作记录包含 5 个数据项：返回地址和 4 个实在参数，并以递归函数中的语句行号表示返回地址，同时假设主函数的返回地址为 0。图 3.7 中表示栈顶指针。

实际上，在调用函数和被调用函数之间不一定传递参数的值，也可以传递参数的地址。通常，每个程序设计语言都有它自己约定的传递方法（包括被调用函数的执行结果如何返回调用函数等），读者将会在后续课程中学到其细节。

由于递归函数结构清晰，程序易读，而且它的正确性容易得到证明，因此，利用允许递归调用的语言（例如 C 语言）进行程序设计时，给用户编制程序和调试程序带来很大方便。因为对这样一类递归问题编程时，不需用户自己而由系统来管理递归工作栈。

###### Hani 塔的递归函数运行示意图

![](https://gitee.com/mayundaze/img_bed/raw/master/20200617163543.png)
![](https://gitee.com/mayundaze/img_bed/raw/master/20200617163443.png)
