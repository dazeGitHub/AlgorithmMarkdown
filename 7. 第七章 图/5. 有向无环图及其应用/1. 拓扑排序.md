
#### 拓扑排序

##### 1. 拓扑排序的定义

什么是拓扑排序（Topological Sort）？简单地说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。

###### 离散数学中关于偏序和全序的定义

> 若集合 $X$ 上的关系 $R$ 是自反的、反对称的和传递的，则称 $R$ 是集合 $X$ 上的偏序关系。
>
> 设 $R$ 是集合 $X$ 上的偏序（Partial Order），如果对每个 $x,y \in X$ 必有 $xRy$ 或 $yRx$，则称 $R$ 是集合 $X$ 上的全序关系。

直观地看，偏序指集合中仅有部分成员之间可比较，而全序指集合中全体成员之间均可比较。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200703180124.png)

例如，图 7.25 所示的两个有向图，图中弧 $\langle x, y\rangle$ 表示 $x \leq y$，则 $(a)$ 表示偏序，$(b)$ 表示全序。若在 $(a)$ 的有向图上人为地加一个表示 $v_{2} \leqslant v_{3}$ 的弧（符号“≤”表示 $v_2$ 领先于 $v_3$），则 $(a)$ 表示的亦为全序，且这个全序称为 **拓扑有序（Topological Order）**，而由偏序定义得到拓扑有序的操作便是 **拓扑排序**。

一个表示偏序的有向图可用来表示一个流程图。它或者是一个施工流程图，或者是个产品生产的流程图，再或是一个数据流图（每个顶点表示一个过程）。图中每一条有向边表示两个子工程之间的次序关系（领先关系）。

例如，一个软件专业的学生必须学习一系列基本课程（如图 7.26 所示）

![](https://gitee.com/mayundaze/img_bed/raw/master/20200703180730.png)

其中有些课程是基础课，它独立于其他课程，如《高等数学》；而另一些课程必须在学完作为它的基础的先修课程才能开始。如，在《程序设计基础》和《离散数学》学完之前就不能开始学习《数据结构》。这些先决条件定义了课程之间的领先（优先）关系。

##### 2. AOV-网

这个关系可以用有向图更清楚地表示，如图 7.27 所示。图中顶点表示课程，有向边（弧）表示先决条件。若课程 i 是课程 j 的先决条件，则图中有 弧$(i, j)$。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200703180802.png)

这种用顶点表示活动，用弧表示活动间的优先关系的有向图称为 **顶点表示活动的网（Activity On Vertex Network）**，简称 **AOV-网**。在网中，若从顶点 i 到顶点 j 有一条有向路径，则 i 是 j 的前驱，j 是 i 的后继。若 $\langle i, j\rangle$ 是网中一条弧，则 i 是 j 的直接前驱；j 是 i 的直接后继。

在 AOV-网 中，不应该出现有向环，因为存在环意味着某项活动应以自己为先决条件。显然，这是荒谬的。若设计出这样的流程图，工程便无法进行。而对程序的数据流图来说，则表明存在一个死循环。因此，对给定的 AOV 网应首先判定网中是否存在环。检测的办法是对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该 AOV-网 中必定不存在环。

例如，图 7.27 的有向图有如下两个拓扑有序序列：

$\left(C_{1}, C_{2}, C_{3}, C_{1}, C_{5}, C_{7}, C_{9}, C_{10}, C_{11}, C_{6}, C_{12}, C_{8}\right)$

和

$\left(C_{9}, C_{10}, C_{11}, C_{6}, C_{1}, C_{12}, C_{4}, C_{2}, C_{3}, C_{5}, C_{7}, C_{8}\right)$

（当然，对此图也可构造得其他的拓扑有序序列）。若某个学生每学期只学一门课程的话，则他必须按拓扑有序的顺序来安排学习计划。

##### 3. 进行拓扑排序的方法

如何进行拓扑排序？解决的方法很简单：

（1) 在有向图中选一个没有前驱的顶点且输出之
（2) 从图中删除该顶点和所有以它为尾的弧。

重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后种情况则说明有向图中存在环。

以图 $7.28(a)$ 中的有向图为例，图中，$v_1$ 和 $v_6$ 没有前驱，则可任选一个。假设先输出 $v_6$，在删除 $v_6$ 及弧 $\left\langle v_{6}, v_{4}\right\rangle$，$\left\langle v_{6}, v_{5}\right\rangle$ 之后，只有顶点 $v_1$ 没有前驱，则输出 $v_1$ 且删去 $v_1$ 及 $\left\langle v_{1}, v_{2}\right\rangle$、$\left\langle v_{1}, v_{3}\right\rangle$ 和 $\left\langle v_{1}, v_{4}\right\rangle$，之后 $v_3$ 和 $v_4$ 都没有前驱。依次类推，可从中任选一个继续进行。整个拓扑排序的过程如图 7.28 所示。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200706094714.png)

最后得到该有向图的拓扑有序序列为：$v_{6}-v_{1}-v_{1}-v_{3}-v_{2}-v_{5}$

如何在计算机中实现？针对上述两步操作，我们可采用邻接表作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组（indegree）。入度为零的顶点即为没有前驱的顶点，删除顶点及以它为尾的弧的操作，则可换以弧头顶点的入度减 1 来实现。

为了避免重复检测入度为零的顶点，可另设一暂存所有入度为零的顶点，由此可得拓扑排序的算法如算法 7.12 所示。

###### 算法 7.12

```cpp
Status TopologicalSort(Algraph G){

    //有向图 G 采用邻接表存储结构。
    //若 G 无回路，则输出 G 的顶点的一个拓扑序列并返回 OK，否则 ERROR。

    FindInDegree(G, indegree);      //对各顶点求入度 indegree[0... vernum - 1]
    InitStack(S);

    for(i = 0; i < G.vexnum; ++ i)  //建零入度顶点 S
        if (!indegree[i]) 
            Push(S, i);             //入度为 0 者进栈

    count = 0;                      //对输出顶点计数

    while(!StackEmpty(S)){

        Pop(S, i); 
        printf(i,G.vertices[i].data); 
        ++ count;                   //输出 i 号顶点并计数 

        for(p = G.vertices[i].firstarc; p; p = p-> nextarc){
            k = p -> adjvex;        //对 i 号顶点的每个邻接点的入度减 1

            if (! (--indegree[k]))
                Push(S, k);         //若入度减为 0, 则入栈
        }//for

    }//while

    if (count < G. Vexnum) 
        return ERROR;               //该有向图有回路 
    else 
        return OK;

}// TopologicalSort
```

分析算法 7.12, 对有 $n$ 个顶点和 $e$ 条弧的有向图而言，建立求各顶点的入度的时间复杂度为 $O(e)$；建零入度顶点栈的时间复杂度为 O(n；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减 1 的操作在 WHILE 语句中总共执行 e 次，所以，总的时间复杂度为 O(n + e）。上述拓扑排序的算法亦是下节讨论的求关键路径的基础。

当有向图中无环时，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索遍历时，最先退出 DFS 函数的顶点即出度为零的顶点，是拓扑有序序列中最后一个顶点。由此，按退出 DFS 函数的先后记录下来的顶点序列（如同求强连通分量时 finished 数组中的顶点序列）即为逆向的拓扑有序序列。
