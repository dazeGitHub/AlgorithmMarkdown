
#### 深度优先搜索

##### 1. 什么是深度优先搜索

深度优先搜索（Depth_First Search）遍历类似于树的先根遍历，是树的先根遍历的推广。

##### 2. 深度优先搜索的过程

假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可从图中某个顶点出发，访问此顶点，然后依次从 $v$ 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 $v$ 有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200703102108.png)

以图 7.13 (a）中无向图 $G_4$ 为例，深度优先搜索遍历图的过程如图 $7.13(b)$ 所示。假设从顶点 $v_1$ 出发进行搜索，在访问了顶点 $v_1$ 之后，选择邻接点 $v_2$。因为 $v_2$ 未曾访问，则从 $v_2$ 出发进行搜索。依次类推，接着从 $v_4，v_8，v_5$ 出发进行搜索。在访问了 $v_5$ 之后，由于 $v_5$ 的邻接点都已被访问，则搜索回到 $v_8$。由于同样的理由，搜索继续回到 $v_4$，$v_2$ 直至 $v_1$，此时由于 $v_1$ 的另一个邻接点未被访问，则搜索又从 $v_1$ 到 $v_3$，再继续进行下去。由此，得到的顶点访问序列为：

$\qquad v_{1} \rightarrow v_{2} \rightarrow v_{4} \rightarrow v_{8} \rightarrow v_{3} \rightarrow v_{3} \rightarrow v_{6} \rightarrow v_{7}$

显然，这是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组 $visited[0 \cdot n-1]$，其初值为“false”，一旦某个顶点被访问，则其相应的分量置为 “true”。整个图的遍历如算法 7.4 和 7.5 所示，其中 $w \geqslant 0$ 表示存在邻接点。

###### 算法 7.4

```cpp
//--- 算法 7.4 和 7.5 使用的全局变量 ---
Boolean visited[MAX];                                   //访问标志数组，类型是 Boolean
Status (* VisitFunc)(int v);                            //函数变量

void DFSTraverse(Graph G, Status(* Visit)(int v)){      //对图 G 作深度优先遍历

    VisitFunc = Visit;                                  //使用全局变量 VisitFunc，使 DFS 不必设函数指针参数

    for(v = 0; V < G.vexnum; ++v) 
        visited[v] = FALSE;                             //访问标志数组初始化

    for(v = 0; v < G.vexnum; ++v)
        if (!visited[v]) 
            DFS(G, v);                                  //对尚未访问的顶点调用 算法 7.5 的 DFS
```

###### 算法 7.5

```cpp
// 从第 ⅴ 个顶点出发递归地深度优先遍历图 G
void DFS(Graph G, int v){
   
    visited[v] = TRUE; 
    
    VisitFunc(v);                                       //访问第 v 个顶点

    for(w = FirstAdiVex(G, v); w >= 0; w = NextAdiVex(G, v, w))
        if (!visited[w]) 
            DFS(G,w);                                   //对 v 的尚未访问的邻接顶点 w 递归调用 DFS
}
```

> adjoin : [əˈdʒɔɪn] 邻接

分析上述算法，在遍历图时，对图中每个顶点至多调用一次 DFS 函数，因为一旦某个顶点被标志成已被访问，就不再从它出发进行搜索。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程。其耗费的时间则取决于所采用的存储结构。当用二维数组表示邻接矩阵作图的存储结构时，査找每个顶点的邻接点所需时间为 $O(n^2)$，其中 n 为图中顶点数。而当以邻接表作图的存储结构时，找邻接点所需时间为 $O(e)$，其中 e 为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为 $O(n + e)$
