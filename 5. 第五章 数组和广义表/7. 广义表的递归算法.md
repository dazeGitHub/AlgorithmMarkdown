
#### 广义表的递归算法

在第 3 章中曾提及，递归函数结构清晰、程序易读，且容易证明正确性，因此是程序设计的有力工具，但有时递归函数的执行效率很低，因此使用递归应扬长避短。在程序设计的过程中，我们并不一味追求递归。如果一个问题的求解过程有明显的递推规律，我们也很容易写出它的递推过程（如求阶乘函数 $f(n) = n!$ 的值），则不必要使用“递归”。反之，在对问题进行分解、求解的过程中得到的是和原问题性质相同的子问题（如 Hanoi 塔问题），由此自然得到一个递归算法，且它比利用栈实现的非递归算法更符合人们的思维逻辑，因而更易于理解。但是要熟练掌握递归算法的设计方法也不是件轻而易举的事情。在本节中，我们不打算全面讨论如何设计递归算法，只是以广义表为例，讨论如何利用“分治法”（$Divide \; and \; Conquer$）进行递归算法设计的方法

对这类问题设计递归算法时，通常可以先写出问题求解的递归定义。和第二数学归纳法类似，递归定义由 **基本项** 和 **归纳项** 两部分组成。

递归定义的基本项描述了一个或几个递归过程的终结状态。虽然一个有限的递归（且无明显的迭代）可以描述一个无限的计算过程，但任何实际应用的递归过程，除错误情况外，必定能经过有限层次的递归而终止。所谓终结状态指的是不需要继续递归而可直接求解的状态。如例 $3-3$ 的 $n$ 阶 $Hanoi$ 塔问题，在 $n = 1$ 时可以直接求得解，即将圆盘从 $X$ 塔座移动到 $Z$ 塔座上。一般情况下，若递归参数为 $n$，则递归的终结状态为 $n = 0$ 或 $n = 1$ 等。

递归定义的归纳项描述了如何实现从当前状态到终结状态的转化。递归设计的实质是：

* 当一个复杂的问题可以分解成若干子问题来处理时，其中某些子问题与原问题有相同的特征属性，则可利用和原问题相同的分析处理方法；反之，这些子问题解决了，原问题也就迎刀而解了。

递归定义的归纳项就是描述这种原问题和子问题之间的转化关系。

###### 实例

仍以 Hani 塔问题为例。

原问题是将 $n$ 个圆盘从 $X$ 塔座移至 $Z$ 塔座上，可以把它分解成 3 个子问题：

$(1)$ 将编号为 $1$ 至 $n - 1$ 的 $n - 1$ 个圆盘从 $X$ 塔座移至 $Y$ 塔座；
$(2)$ 将编号为 $n$ 的圆盘从 $X$ 塔座移至 $Z$ 塔座；
$(3)$ 将编号为 $1$ 至 $n - 1$ 的圆盘从 $Y$ 塔座移至 $Z$ 塔座。

其中 $(1)$ 和 $(3)$ 的子问题和原问题特征属性相同，只是参数（$n - 1$ 和 $m$）不同，由此实现了递归。

由于递归函数的设计用的是归纳思维的方法，则在设计递归函数时，应注意：

$(1)$ 首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原问题性质相同的子问题，只要接口一致，便可进行递归调用；
$(2)$ 对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想得太深太远。正如用第二数学归纳法证明命题时，由归纳假设进行归纳证明时绝不能怀疑归纳假设是否正确。

下面讨论广义表的 3 种操作。首先约定所讨论的广义表都是非递归表且无共享子表。
