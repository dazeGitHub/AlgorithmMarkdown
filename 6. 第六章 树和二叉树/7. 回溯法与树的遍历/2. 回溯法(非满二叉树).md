
#### 例 6-4

求 4 皇后问题的所有合法布局（作为例子，我们将 8 皇后问题简化为 4 皇后问题）

> 8 皇后问题是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例
> 8 皇后问题表述为：在 8 × 8 格的国际象棋上摆放 8 个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有 76 种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出 92 种结果。如果经过 ±90度、±180 度旋转，和对角线对称变换的摆法看成一类，共有42类。计算机发明后，有多种计算机语言可以编程解决此问题。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200630171336.png)

图 6.29 展示求解过程中棋盘状态的变化情况。这是一棵四叉树，树上每个结点表示一个局部布局或一个完整的布局。根结点表示棋盘的初始状态：棋盘上无任何棋子。

##### 4 皇后的条件

每个（皇后）棋子都有 4 个可选择的位置，但在任何时刻，棋盘的合法布局都必须满足 3 个约束条件: 即任何两个棋子都不占据棋盘上的同一行、或者同一列、或者同一对角线。

图 6.29 中除结点 a (最下边倒数第二个结点)之外的叶子结点都是不合法的布局

##### 求解过程

求所有合法布局的过程即为在上述约束条件下先根遍历图 6.29 的状态树的过程。

遍历中访问结点的操作为，判别棋盘上是否已得到一个完整的布局（即棋盘上是否已摆上 4 个棋子），若是，则输出该布局；否则依次先根遍历满足约束条件的各棵子树，即首先判断该子树根的布局是否合法，若合法，则先根遍历该子树，否则剪去该子树分支。算法 6.16 为求所有合法布局的伪码算法：

###### 算法 6.16

```cpp
//i 表示行，棋盘时 n x n 的
void Trial(int i, int n){
    //进入本函数时，在 n x n 棋盘前 i - 1 行已放置了互不攻击的 i - 1 个棋子 (因为递归调用了 Trial 方法)
    //现从第 i 行起继续为后续棋子选择合适位置
    //当 i > n 时，求得一个合法布局，输出之
    if (i > n）
        输出棋盘的当前布局；                //n 为 4 时，即为 4 皇后问题 
    else 
        for(j = 1;j <= n; ++j){          //遍历第 i 行的所有 j 列，并在第 i 行第 j 列放置一个棋子
            if（当前布局合法）
                Trial(i + 1, n);         //如果当前布局合法，则继续在第 i + 1 行放置棋子

            移走第 i 行第 j 列的棋子        //尝试了第 i 行 j 列的情况，之后要尝试第 j + 1 的情况，所以要把第 i 行第 j 列的棋子移除掉
        }
}//Trial
```

算法 6.16 可进一步求精，在此从略。算法 6.16 可作为回溯法求解的一般模式，类似问题有骑士游历、迷宫问题、选最优解问题等等