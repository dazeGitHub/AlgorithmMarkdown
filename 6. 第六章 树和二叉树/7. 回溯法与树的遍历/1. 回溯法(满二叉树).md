
在程序设计中，有相当一类求一组解、或求全部解或求最优解的问题，例如读者熟悉的八皇后问题等，不是根据某种确定的计算法则，而是利用 试探 和 回湖（Backtracking）的捜索技术求解。回溯法也是设计递归过程的一种重要方法，它的求解过程实质上是一个先序遍历一棵“状态树”的过程，只是这棵树不是遍历前预先建立的，而是隐含在遍历过程中，但如果认识到这点，很多问题的递归过程设计也就迎刀而解了。为了说明问题，先看一个简单例子。

#### 例 6-3 

求含 n 个元素的集合的幂集。
集合 A 的幂集是由集合 A 的所有子集所组成的集合。如：$A = \{1,2,3\}$，则 A 的幂集

$\qquad\rho(A)=\{\{1,2,3\},\{1,2\},\{1,3\},\{1\},\{2,3\},\{2\},\{3\}, \Phi\} \qquad (6-6)$

当然，可以用 5.7 节介绍的分治法来设计这个求幂集的递归过程。在此，从另一角度分析问题。幂集的每个元素是一个集合，它或是空集，或含集合 A 中一个元素，或含集合 A 中两个元素，或等于集合 A。反之，从集合 A 的每个元素来看，它只有两种状态：它或属幂集的元素集，或不属幂集元素集。则求幂集 p (A）的元素的过程可看成是依次对集合 A 中元素进行 “取” 或 “舍（弃）” 的过程，如图:

![](https://gitee.com/mayundaze/img_bed/raw/master/20200630164546.png)

并且可以用一棵如图 6.28 所示的二叉树，来表示过程中幂集元素的状态变化状况，树中的根结点表示幂集元素的初始状态（为空集）；叶子结点表示它的终结状态（如图 6.28 中 8 个叶子结点表示式（6-6) 中释集 P (A）的 8 个元素）；而第 $i(i=2,3, \cdots, n-1)$ 层的分支结点，则表示已对集合 A 中前 i - 1 个元素进行了 取/舍处理的当前状态(左分支表示“取”,右分支表示“舍”）。

> 解析: 
> 1. 结点 [1] 是第 2 层 (i = 2)，表示已经对集合 $A = \{1,2,3\}$ 中第 i - 1 = 2 - 1 = 1 个元素进行了"取”处理，所以当前状态是 1
> 2. 结点 [1,2] 是第 3 层 (i = 3)，表示已经对集合 $A = \{1,2,3\}$ 中第 i - 1 = 3 - 1 = 2 个元素进行了“取”处理，所以当前状态时 1,2
> 3. 其他以此类推

因此求幂集元素的过程即为先序遍历这棵状态树的过程，如算法 6.14 所描述。

###### 算法 6.14

```cpp
void PowerSet(int i, int n){
    //求含 n 个元素的集合 A 的幂集 p(A)。进入函数时已对 A 中前 i - 1 个元素作了取舍处理
    //现从第 i 个元素起进行取舍处理。若 i > n，则求得幂集的一个元素，并输出之。
    //初始调用：PowerSet(1,n); 
    if (i > n）
        输出幂集的一个元素;
    else{
        取第 i 个元素；PowerSet(i + 1, n);
        舍第 i 个元素；PowerSet(i + 1, n);
    }
}//PowerSet
```

对算法 6.14 求精需确定数据结构。假设以线性表表示集合，则求精后的算法如算法 6.15 所示。

###### 算法 6.15

```cpp
void GetPowerSet(int i, List A, List & B){
    //线性表 A 表示集合 A，线性表 B 表示幂集 p(A) 的一个元素。
    //局部量 k 为进入函数时表 B 的当前长度。第一次调用本函数时，B 为空表，i=1。
    
    if (i > ListLength(A))
        Output(B);                                 //输出当前 B 值，即 p(A）的一个元素
    else{
        GetElem(A, i, x);
        k = ListLength (B);

        ListInsert(B, k + 1, x); 
        GetPowerSet(i + 1, A, B);

        ListDelete(B, k + 1, x); 
        GetPowerSet(i + 1, A, B);
    }
}//GetPowerSet
```

图 6.28 中的状态变化树是一棵满二叉树，树中每个叶子结点的状态都是求解过程中，可能出现的状态（即问题的解）。然而很多问题用回溯和试探求解时，描述求解过程的状态树不是一棵满的多叉树。当试探过程中出现的状态和问题所求解产生矛盾时，不再继续试探下去，这时出现的叶子结点不是问题的解的终结状态。这类问题的求解过程可看成是在约束条件下进行先序（根）遍历，并在遍历过程中剪去那些不满足条件的分支。具体见 `2. 回溯法(非满二叉树).md`
