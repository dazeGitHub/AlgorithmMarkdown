
#### 1. 什么是赫夫曼编码

目前，进行快速远距离通信的主要手段是电报，即将需传送的文字转换成由二进制的字符组成的字符串。例如，假设需传送的电文为 'A B A C C D A'，它只有 4 种字符，只需两个字符的串便可分辨。假设 A、B、C、D 的编码分别为 00、01、10 和 11, 则上述 7 个字符的电文便为 0010010101100, 总长 14 位，对方接收时，可按二位一分进行译码。

当然，在传送电文时，希望总长尽可能地短。

如果对每个字符设计长度不等的编码，且让电文中出现次数较多的字符采用尽可能短的绵码，则传送电文的总长便可减少。如果设计 A、B、C、D 的编码分别为 0、00、1 和 01, 则上述 7 个字符的电文可转换成总长为 9 的字符串'000011010。但是，这样的电文无法翻译，例如传送过去的字符串中前 4 个字符的子串 000 就可有多种译法，或是'AAAA'，或是'ABA'，也可以是'BB'等。因此，若要设计长短不等的编码，则必须是任一个字符的编码都不是另一个字符的编码的前缀，这种编码称做 **前缀编码**。

可以利用二叉树来设计二进制的前缀编码。假设有一棵如图 6.25 所示的二叉树，其 4 个叶子结点分别表示 A、B、C、D 这 4 个字符，且约定左分支表示字符'0'，右分支表示字符 1'，则可以从根结点到叶子结点的路径上分支字符组成的字符串作为该叶子结点字符的编码。读者可以证明，如此得到的必为二进制前缀编码。如由图 6.25 所得 A、B、C、D 的二进制前缀编码分别为 0、10、110 和 111

![](https://gitee.com/mayundaze/img_bed/raw/master/20200630144900.png)

又如何得到使电文总长最短的二进制前缀编码呢？假设每种字符在电文中出现的次数为 $w_i$，其编码长度为 $l_i$，电文中只有 n 种字符，则电文总长为 $\sum_{i=1}^{n} w_{i} l_{i}$。对应到二叉树

上，若置 $w_i$ 为叶子结点的权，$l_i$ 恰为从根到叶子的路径长度。则 $\sum_{i=1}^{n} w_{i} l_{i}$ 恰为二叉树上带权路径长度。由此可见，设计电文总长最短的二进制前缀编码即为以 n 种字符出现的频率作权，设计一棵赫夫曼树的问题，由此得到的二进制前缀编码便称为 **赫夫曼编码**

#### 2. 赫夫曼编码的实现

由于赫夫曼树中没有度为 1 的结点（这类树又称严格的（strict)（或正则的）二叉树），则一棵有 n 个叶子结点的赫夫曼树共有 $2n-1$ 个结点，可以存储在一个大小为 $2n-1$ 的维数组中。

如何选定结点结构？由于在构成赫夫曼树之后，为求编码需从叶子结点出发走一条从叶子到根的路径；而为译码需从根出发走一条从根到叶子的路径。则对每个结点而言，既需知双亲的信息，又需知孩子结点的信息。由此，设定下述存储结构：

```cpp
//ーーー-- 赫夫曼树和赫夫曼编码的存储表示 
typedef struct{
    unsigned int weight;
    unsigned int parent, lchild, rchild;
}HTNode, * HuffmanTree;                                    //动态分配数组存储赫夫曼树 

typedef char * * HuffmanCode;                              //动态分配数组存储赫夫曼编码表
```

求赫夫曼编码的算法如算法 6.12 所示。

###### 算法 6.12

```cpp
void HuffmanCoding (HuffmanTree & HT, HuffmanCode & HC, int * w, int n){

    //w 存放 n 个字符的权值(均 > 0)，构造赫夫曼树 HT，并求出 n 个字符的赫夫曼编码 HC

    if (n <= 1) return;
    m = 2 * n - 1;                                         //总的结点数
    HT = (HuffmanTree) malloc ((m + 1) * sizeof (HTNode)); //0 号单元未用 

    for (p = HT, i = 1; i <= n; ++i, ++p, ++w) 
        *p = (*w,0,0,0}; 
        
    for (; i <= m; ++i, ++p) 
        *p = {0,0,0,0}; 
        
    for (i = n + 1; i <= m; ++i) (                          //建赫夫曼树
        //在 HT[1.. i - 1] 选择 parent 为 0 且 weight 最小的两个结点，其序号分别为 s1 和 s2
        Select (HT, i - 1, s1, s2);
        HT[s1].parent = i; 
        HT[s2].parent = i;
        HT[i].lchild = s1; 
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }

    //ー--从叶子到根逆向求每个字符的赫夫曼编码
    HC = (HuffmanCode) malloc((n + 1) * sizeof(char*));     //分配 n 个字符编码的头指针向量 
    cd = (char *) malloc (n * sizeof(char));                //分配求编码的工作空间 
    cd[n - 1] = "\0";                                       //编码结東符
    
    for (i = 1; i <= n; ++i){                               //逐个字符求赫夫曼编码
        start = n - 1;                                      //编码结束符位置
        for (c = i, f = HT[i].parent; f!=0; c = f,f = HT[f].parent) //从叶子到根逆向求编码
            if (HT[f].lchild == c)
                cd [--start] = "0";
            else 
                cd [--start] = "1";

        H[i] = (char *)malloc((n - start) * sizeof(char));  //为第 i 个字符编码分配空间 
        strcpy(HC[i], &cd[start]);                          //从 cd 复制编码（串）到 HC
    }
    free(cd);                                               //释放工作空间 
}// Huffancoding
```

向量 HT 的前 n 个分量表示叶子结点，最后一个分量表示根结点。各字符的编码长度不等，所以按实际长度动态分配空间。在算法 6.12 中，求每个字符的赫夫曼编码是从叶子到根逆向处理的。也可以从根出发，遍历整棵赫夫曼树，求得各个叶子结点所表示的字符的赫夫曼编码，如算法 6.13 所示（因为已经是赫夫曼树，权重乘路径的和最短，所以从根出发和从叶子出发得到的赫夫曼编码长度是相同的）。

###### 算法 6.13

```cpp
//ーーー-- 无栈非递归遍历赫夫曼树，求赫夫曼编码 
HC = (HuffmanCode)malloc((n + 1) * sizeof (char *));
p = m; cdlen = 0;

for(i = 1; i <= m; ++i) 
    HT[i].weight = 0;                                       //遍历赫夫曼树时用作结点状态标志 
    
while(p){
    if(HT[p].weight == 0){                                  //向左
        HT[p].weight = 1;

        if(HT[p].lchild != 0){
            p = HT[p].lchild; 
            cd[cdlen ++] = "0";
        }else if(HT[p].rchild == 0){                         //登记叶子结点的字符的编码
            HC[p] = (char *) malloc ((cdlen + 1) * sizeof (char))
            cd[cdlen] = "\0"; 
            strcpy(HC[p], cd);                               //复制编码（串）
        }
    }
    else if(HT[p].weight == 1){                              //向右
        HT[p].weight = 2;
        if(HT[p].rchild != 0){
            p = HT[p].rchild; 
            cd[cdlen ++] = "1";
        }
    }else{
        HT[p].weight == 0;
        p = HT[p].parent; 
        --cdlen;                                             //退到父结点，编码长度减 1 
    }//else
}// While
```
