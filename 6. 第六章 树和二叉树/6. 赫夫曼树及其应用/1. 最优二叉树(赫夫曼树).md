
#### 最优二叉树(赫夫曼树)

赫夫曼（Huffman）树，又称最优树，是一类带权路径长度最短的树，有着广泛的应用。本节先讨论最优二叉树。

首先给出路径和路径长度的概念。从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称做路径长度。树的路径长度是从树根到每结点的路径长度之和。6.2.1 节中定义的完全二叉树就是这种路径长度最短的二叉树

若将上述概念推广到一般情况，考虑带权的结点。**结点的带权路径长度** 为从该结点到树根之间的路径长度与结点上权的乘积。**树的带权路径长度** 为树中所有叶子结点的带权路径长度之和，通常记作:

$\qquad WPL = \sum_{k=1}^{n} w_{k} l_{k}$

> 其中 $l$ 是路径，$w$ 是权

假设有 n 个权值 $\left\{w_{1}, w_{2}, \cdots, w_{n}\right\}$，试构造一棵有 n 个叶子结点的二叉树，每个叶子结点带权为 $w_i$，则其中带权路径长度 WPL 最小的二叉树称做 **最优二叉树** 或 **赫夫曼树**。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200630140243.png)

例如，图 6.22 中的 3 棵二叉树，都有 4 个叶子结点 a、b、c、d，分别带权 7、5、2、4, 它们的带权路径长度分别为

$(a) WPL = 7 \times 2 + 5 \times 2 + 2 \times 2 + 4 \times 2 = 36$
$(b) WPL = 7 \times 3 + 5 \times 3 + 2 \times 1 + 4 \times 2 = 46$ 
$(c) WPL = 7 \times 1 + 5 \times 2 + 2 \times 3 + 4 \times 3 = 35$

其中以（c）树的为最小。可以验证，它恰为赫夫曼树，即其带权路径长度在所有带权为 7、5、2、4 的 4 个叶子结点的二又树中居最小。

在解某些判定问题时，利用赫夫曼树可以得到最佳判定算法。例如，要编制一个将百分制转换成五级分制的程序。显然，此程序很简单，只要利用条件语句便可完成。如

```cpp
if (a < 60) b = "bad";
else if (a < 70) b = "pass";
    else if (a < 80) b = "general";
        else if (a < 90) b = "good";
            else b = "excellent";
```

这个判定过程可以图 6:23 (a）的判定树来表示。

如果上述程序需反复使用，而且每次的输入量很大，则应考虑上述程序的质量问题，即其操作所需时间。因为在实际生活中，学生的成绩在 5 个等级上的分布是不均匀的。假设其分布规律如下表所示：

![](https://gitee.com/mayundaze/img_bed/raw/master/20200630141345.png)

因为小于 70 分的有 0.05 + 0.15 = 0.2，即大于 70 分的 80% 以上的数据需进行 3 次或 3 次以上的比较才能得出结果。

根据表格的数据（0.05、0.15、0.40、0.30、0.10），假定以 5,15,40,30 和 10 为权构造一棵有 5 个叶子结点的赫夫曼树，则可得到如图 6.23 (b）所示的判定过程，它可使大部分的数据经过较少的比较次数得出结果。但由于每个判定框都有两次比较（例如 $60 \leq a < 70$)，将这两次比较分开，我们得到如图 6.23 (c）所示的判定树，按此判定树可写出相应的程序。

假设现有 10000 个输人数据，若按图 6.23 (a）的判定过程进行操作，则总共需进行 31500 次比较；而若按图 6.23 (c）的判定过程进行操作，则总共仅需进行 22000 次比较。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200630142124.png)
