
##### 例 6-1

假设集合 $S=\{x \mid 1 \leqslant x \leqslant n \text { 是正数数 }\}$, R 是 S 上的一个等价关系。

$\quad R = \{(1,2),(3,4),(5,6),(7,8),(1,3),(5,7),(1,5), \cdots\}$

现求 S 的等价类。

以 MFSet 类型的变量 S 表示集合 S, S 中成员个数为 S.N。开始时，由于每个成员自成一个等价类，则 S.nodes[i].parent 的值均为 ー1。之后，每处理一个等价偶对 $(i,j)$，首先必须确定 i 和 j 各自所属集合，若这两个集合相同，则说明此等价关系是多余的，无需作处理；否则就合并这两个集合。

图 6.20 展示了处理 R 中前 7 个等价关系时 S 的变化状况（图中省去了结点的数据域），图 6.21(a）所示为和最后一个 S 状态相应的树的形态。显然，随着子集逐对合并，树的深度也越来越大，为了进一步减少确定元素所在集合的时间，我们还可进一步将算法 6.8 改进为算法 6.11。当所查元素 i 不在树的第二层时，在算法中增加一个“压缩路径”的功能，即将所有从根到元素 i 路径上的元素都变成树根的孩子。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200630133509.png)

###### 算法 6.11

```cpp
Int fix_mfset (MFSet & S, int i){
    //确定 i 所在子集，并将从 1 至根路径上所有结点都变成根的孩子结点。
    if(i < 1 || i > S.n) return -1 //i 不是 S 中任一子集的成员 
    for (j = i; S.nodes[j].parent > 0; j = S.nodes[j].parent); 
    for (k = i; k != j; k = t){
        t = S.nodes[k].parent; 
        S.nodes[k].parent = j;
    }
    return j;
}//fix_mfset
```

假设例 6-1 中 R 的第 8 个等价偶对为 $(8,9)$，则在执行 fix (s,8) 的操作之后图 6.21 (a）的树就变成图 6.21 (b）的树。

##### 结论

已经证明，利用算法 fix_mfset 和 mix_mfset 划分大小为 n 的集合为等价类的时间复杂度为 $O(n \alpha(n))^{[6]}$。其中 $a(n)$ 是一个增长极其缓慢的函数，若定义单变量的阿克曼函数为 $A(x) = A(x,x)$，则函数 $a(n)$ 定义为 $A(x)$ 的拟逆，即 $a(n)$ 的值是使 $A(x) \geq n$ 成立的最小 x。所以，对于通常所见到的正整数 n 而言，$a(n) \geq 4$