
树型结构是一类重要的非线性数据结构。其中以树和二叉树最为常用，直观看来，**树 是以 分支关系 定义的 层次结构**。

树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示。树在计算机领域中也得到广泛应用，如在编译程序中，可用树来表示源程序的语法结构。又如在数据库系统中，树形结构也是信息的重要组织形式之一。

本章重点讨论二叉树的存储结构及其各种操作，并研究树和森林与二叉树的转换关系，最后介绍几个应用例子。

#### 树的定义和基本术语

树 $(Tree)$ 是 $n (n \geq 0)$ 个结点的有限集。

在任意一棵非空树中：

$\quad (1)$ 有且仅有一个特定的称为根(Root) 的结点；
$\quad (2)$ 当 $n > 1$ 时，其余结点可分为 $m(m > 0)$ 个互不相交的有限集 `T_1,T_2,\cdots,T_m`，其中每一个集合本身又是一棵树，并且称为根的子树（Subtree）。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200618150524.png)

> 例如，在图 6.1 中，(a）是只有一个根结点的树；(b）是有 13 个结点的树，其中 A 是根，其余结点分成 3 个互不相交的子集：$T_1 = {B, E, F, K, L}, T_2 = {C, G}, T_3 = {D, H, I, J, M}$; $T_1$、$T_2$ 和 $T_3$ 都是根 A 的子树，且本身也是一棵树。例如 $T_1$, 其根为 B，其余结点分为两个互不相交的子集；$T_{11} = {E, K, L}, T_{12} = {F}$，$T_{11}$ 和 $T_{12}$ 都是 B 的子树。而 $T_{11}$ 中 E 是根，${K}$ 和 ${L}$ 是 $E$ 的两棵互不相交的子
树，其本身又是只有一个根结点的树。

上述树的结构定义加上树的一组基本操作就构成了抽象数据类型树的定义。

##### 1. 抽象数据类型树的定义

###### 数据对象 D

D 是具有相同特性的数据元素的集合。

###### 数据关系 R

若 D 为空集，则称为空树；
若 D 仅含一个数据元素，则 R 为空集，否则 R = {H}, H 是如下二元关系： 

$\quad(1)$ 在 D 中存在惟一的称为根的数据元素 root，它在关系 H 下无前驱;
$\quad(2)$ 若 $D - \{root\} \neq \phi$，则存在 $D - \{ root \}$ 的一个划分 $D_1,D_2,\cdots, D_n (m>0$，对任意 $j \neq k (1 \leq j, k \leq m)$ 有 $\mathrm{D}_{\mathrm{j}} \cap \mathrm{D}_{\mathrm{k}}=\Phi$，且对任意的 $i(1 \leqslant i \leqslant m)$，惟一存在数据元素 $\mathbf{x}_{\mathrm{i}} \in \mathrm{D}_{\mathrm{i}}$, 有 くroot, $x_{i}>\in H$

 (3) 对应于 $D-\{\text { root }\}$ 的划分，$\mathrm{H}-\left\{<\text { root }, x_{1}>, \dots,<\text { root }, x_{n}>\right\}$ 有惟一的一个划分 $\mathrm{H}_{1}, \mathrm{H}_{2}, \cdots, \mathrm{H}_{\mathrm{a}}(\mathrm{m}>0)$，对任意 $j \neq k(1 \leqslant j, k \leqslant m)$ 有 $H_{j} \cap H_{k}=\Phi$，且对任意 $i(1 \leqslant 1 \leqslant m), H_{i}$ 是 $D_i$ 上的二元关系，$\left(D_{i},\left\{H_{i}\right\}\right)$ 是一棵符合本定义的树，称为根 root 的子树。

###### 基本操作 P 

```cpp
ADT Tree{

    // 操作结果：构造空树 T
    InitTree (&T);

    //初始条件：树 T 存在。操作结果：销毁树 T
    DestroyTree (&T);
 
    // 初始条件：definition 给出树 T 的定义
    // 操作结果：按 definition 构造树 T
    CreateTree (&T, definition);

    // 初始条件：树 T 存在
    // 操作结果：将树 T 清为空树
    ClearTree (&T);

    // 初始条件：树 T 存在
    // 操作结果：若为空树，则返回 TRUE，否则 FALSE
    TreeEmpty (T);

    // 初始条件：树 T 存在
    // 操作结果：返回 T 的深度
    TreeDepth (T);

    // 初始条件：树 T 存在
    // 操作结果：返回 T 的根
    Root (T);

    // 初始条件：树 T 存在, cur_e 是 T 中某个结点
    // 操作结果：返回 cur_e 的值
    Value (T, cur_e);

    // 初始条件：树 T 存在, cur_e 是 T 中某个结点
    // 操作结果：结点 cur. E 赋值为 value
    Assign (T, cur_e, value):

    // 初始条件：树 T 存在，cur_e 是 T 中某个结点
    // 操作结果：若 cur_e 是 T 的非根结点，则返回它的双亲，否则函数值为“空”
    Parent (T, cur_e);

    // 初始条件：树η存在，cur_e 是 T 中某个结点
    // 操作结果：若 cur_e 是 T 的非叶子结点，则返回它的最左孩子，否则返回“空”
    LeftChild (T, cur_e);

    // 初始条件：树存在，cur_e 是 T 中某个结点
    // 操作结果：若 cur_e 有右兄弟，则返回它的右兄弟，否则函数值为“空
    RightSibling (T, cur_e);

    // 初始条件：树 T 存在，p 指向 T 中某个结点，1 <= i <= p 所指结点的度 +1, 非空树 c 与 T 不相交  //度的定义见后边
    // 操作结果：插入 c 为 T 中 p 指结点的第 i 棵子树
    InsertChild (&T, &p, i, c);

    // 初始条件：树 T 存在，p 指向 T 中某个结点，1 <= i <= p 指结点的度
    // 操作结果：删除 T 中 p 所指结点的第 i 棵子树
    DeleteChild (&T, &p, i);

    // 初始条件：树 T 存在，visit 是对结点操作的应用函数。
    // 操作结果：按某种次序对 T 的每个结点调用函数 visit() 一次且至多一次，一旦 visit（）失败，则操作失败。
    TraverseTree (T, Visit ());

) ADI Tree
```

树的结构定义是一个递归的定义，即在树的定义中又用到树的概念，它道出了树的固有特性。树还可有其他的表示形式，如图 6.2 所示为图 6.1 (b）中树的各种表示。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200618154648.png)

$\quad(a)$ 是以嵌套集合 (即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个) 的形式表示的；
$\quad(b)$ 是以广义表的形式表示的，根作为由子树森林组成的表的名字写在表的左边；
$\quad(c)$ 用的是 `凹入表示法` (类似书的编目)

表示方法的多样化，正说明了树结构在日常生活中及计算机程序设计中的重要性。一般说来，分等级的分类方案都可用层次结构来表示，也就是说，都可导致一个树结构。

##### 2. 树结构中的基本术语

下面列出树结构中的一些基本术语。

树的结点包含一个数据元素及若干指向其子树的分支。**结点拥有的子树数** 称为 **结点的度 (Degree)**

例如，在图 6.1 (b）中，A 的度为 3, C 的度为 1, F 的度为 0。度为 0 的结点称为 **叶子 (Lea)** 或 **终端结点**。图 6.1 (b）中的结点 K、L、F、G、M、1、J 都是 **树的叶子**。度不为 0 的结点称为 **非终端结点** 或 **分支结点**。除根结点之外，分支结点也称为 **内部结点**。

**树的度** 是 **树内各结点的度的最大值**。如图 6.1 (b）的树的度为 3。结点的子树的根称为该 **结点的孩子（Child）**，相应地，该结点称为 **孩子的双亲（Parent）**。例如，在图 6.1 (b）所示的树中，D 为 A 的子树 $T_3 (T_3 = \{D, H, I, J, M \})$ 的根，则 D 是 A 的孩子，而 A 则是 D 的双亲，同一个双亲的孩子之间互称 **兄弟（Sibling）**。例如，H、I 和 J 互为兄弟。将这些关系进一步推广，可认为 D 是 M 的祖父。**结点的祖先** 是从根到该结点所经分支上的所有结点。例如，M 的祖先为 A、D 和 H。反之，以某结点为根的子树中的任一结点都称为该 **结点的子孙**。如 B 的子孙为 E、K、L 和 F。

**结点的层次 (Level）** 从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第 $l$ 层，则其子树的根就在第 $l + 1$ 层。其双亲在同一层的结点互为 **堂兄弟**。例如，结点 G 与 E、F、H、I、J 互为堂兄弟。树中结点的最大层次称为 **树的深度（Depth）** 或 **高度**。图 6.1 (b）所示的树的深度为 4。

如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为 **有序树**，否则称为无序树。在有序树中最左边的子树的根称为 **第一个孩子**，最右边的称为最后一个孩子。

##### 3. 森林

森林（Forest）是 $m (m \geq 0)$ 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以森林和树相互递归的定义来描述树。

就逻辑结构而言，任何一棵树是一个二元组 $Tree = (root, F)$，其中：root 是数据元素，称做树的根结点；F 是 $m (m \geq 0)$ 棵树的森林，$F = (T1, T2, \cdots, Tn）$，其中 $T_i = (r_i, F_i)$ 称做根 root 的第 i 棵子树；当 $m \geq 0$ 时，在树根和其子树森林之间存在下列关系：

$\qquad RF = \left\{<\text { root }, r_{i}>| i=1,2, \cdots, m, m>0\right\}$

这个定义将有助于得到森林和树与二叉树之间转换的递归定义。

树的应用广泛，在不同的软件系统中树的基本操作集不尽相同。