
#### 1. 算法

算法（algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作；

此外，一个算法还具有下列 5 个重要特性：

$(1)$ **有穷性**

一个算法必须总是（对任何合法的输入值）在执行有穷步之后结東，且每一步都可在有穷时间内完成。

$(2)$ **确定性**

算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。并且，在任何条件下，算法只有惟一的一条执行路径，即对于相同的输入只能得出相同的输出。

$(3)$ **可行性**

一个算法是能行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。

$(4)$ **输入**

一个算法有零个或多个的输入，这些输入取自于某个特定的对象的集合

$(5)$ **输出**

一个算法有一个或多个的输出，这些输出是同输入有着某些特定关系的量。

#### 2. 算法设计的要求

通常设计一个“好”的算法应考虑达到以下目标。

$(1)$ **正确性（correctness）** 算法应当满足具体问题的需求。通常一个大型问题的需求，要以特定的规格说明方式给出，而一个实习问题或练习题，往往就不那么严格，目前多数是用自然语言描述需求，它至少应当包括对于输入、输出和加工处理等的明确的无歧义性的描述。设计或选择的算法应当能正确地反映这种需求；否则，算法的正确与否的衡量准则就不存在了。

“正确”一词的含义在通常的用法中有很大差别，大体可分为以下 4 个层次：

a. 程序不含语法错误；
b. 程序对于几组输入数据能够得出满足规格说明要求的结果；
c. 程序对于精心选择的典型、苛刻而带有刁难性的几组输人数据能够得出满足规格说明要求的结果；
d. 程序对于一切合法的输入数据都能产生满足规格说明要求的结果。显然，达到第 d 层意义下的正确是极为困难的，所有不同输入数据的数量大得惊人，逐一验证的方法是不现实的。对于大型软件需要进行专业测试，而一般情况下，通常以第 c 层意义的正确性作为衡量一个程序是否合格的标准。

$(2)$ **可读性（readability）** 算法主要是为了人的阅读与交流，其次才是机器执行。可读性好有助于人对算法的理解；晦涩难懂的程序易于隐藏较多错误，难以调试和修改。

$(3)$ **健壮性（robustness）** 当输人数据非法时，算法也能适当地做出反应或进行处理，而不会产生莫明其妙的输出结果。例如，一个求凸多边形面积的算法，是采用求各角形面积之和的策略来解决问题的。当输入的坐标集合表示的是一个凹多边形时，不应继续计算，而应报告输入出错。并且，处理出错的方法应是返回一个表示错误或错误性质的值，而不是打印错误信息或异常，并中止程序的执行，以便在更高的抽象层次上进行处理。

$(4)$ **效率与低存储量需求** 通俗地说，效率指的是算法执行的时间。对于同一个问题如果有多个算法可以解决，执行时间短的算法效率高。存储量需求指算法执行过程中所需要的最大存储空间。效率与低存储量需求这两者都与问题的规模有关。求 100 个人的平均分与求 1000 个人的平均分所花的执行时间或运行空间显然有一定的差别。

#### 3. 算法效率的度量

算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。

$(1)$ 事后统计的方法因为很多计算机内部都有计时功能，有的甚至可精确到毫秒级，不同算法的程序可通过一组或若干组相同的统计数据以分辨优劣。

但这种方法有两个缺陷：一是必须先运行依据算法编制的程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。因此人们常常采用另一种事前分析估算的方法。

$(2)$ 事前分析估算的方法一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：

① 依据的算法选用何种策略；
② 问题的规模，例如求 100 以内还是 1000 以内的素数；
③ 书写程序的语言，对于同一个算法，实现语言的级别越高，执行效率就越低；
④ 编译程序所产生的机器代码的质量；
⑤ 机器执行指令的速度；

显然，同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行时，效率均不相同。这表明使用绝对的时间单位衡量算法的效率是不合适的。撇开这些与计算机硬件、软件有关的因素，可以认为一个特定算法“运行工作量”的大小，只依赖于问题的规模（通常用整数量 n 表示），或者说，它是问题规模的函数。

一个算法是由控制结构（顺序、分支和循环 3 种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间量度。

例如，在如下所示的两个 N X N 矩阵相乘的算法中，“乘法”运算是“矩阵相乘问题”的基本操作。整个算法的执行时间与该基本操作（乘法）重复执行的次数 3 成正比，记作 $T (n) = O(n^3)$

> ① “O“的形式定义为 : 若 $f(n)$ 是正整数 $n$ 的一个函数，则 $x_n = O(f(n))$ 表示存在一个正的常数 $M$，使得当 $n \geq n_0$ 时都满足 $|x_n| \leq M|f(n)|$

```c
for (i = 1; i <= n: ++i)
    for (j = 1: j <= n: ++j) (
        c[i][j] = 0;
        for(k = 1;k <= n; ++k)
            c[i][j] += a[i][k] * b[k][j];
    }
```

一般情况下，算法中基本操作重复执行的次数是问题规模 $n$ 的某个函数 $f(n)$，算法的时间量度记作

$\qquad T (n) = O(f(n)) \qquad\qquad\qquad (1-5)$

它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n）的增长率相同，称做算法的 **渐近时间复杂度（asymptotic time complexity）**，简称 **时间复杂度**。

显然，被称做问题的基本操作的原操作应是其重复执行次数和算法的执行时间成正比的原操作，多数情况下它是最深层循环内的语句中的原操作，它的执行次数和包含它的语句的频度相同。

**语句的频度（frequency count）** 指的是该语句重复执行的次数，例如，在下列 3 个程序段中：

```c
(a) {++ x; s = 0; }

(b) for (i = 1; i <= n; ++ i) (++ x; s += x;}

(c) for (j = 1; j<= n: ++ j)
        for (k = 1; k <= n; ++k) (++ x; s += x;}
```

含基本操作“x 增 1”的语句的频度分别为 1、$n$ 和 $n^2$, 则这 3 个程序段的时间复杂度分别为 $O(1)$、$O(n)$ 和 $O(n^2)$ ，分别称为常量阶、线性阶和平方阶。算法还可能呈现的时间复杂度有对数阶 $O (log \; n)$、指数阶 $O (2^n)$ 等。不同数量级时间复杂度的性状如图 1.7 所示从图中可见，我们应该尽可能选用多项式阶 $O(n^k)$ 的算法，而不希望用指数阶的算法。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200601114725.png)

一般情况下，对一个问题（或一类算法）只需选择一种基本操作来讨论算法的时间复杂度即可，有时也需要同时考虑几种基本操作，甚至可以对不同的操作赋予不同权值，以反映执行不同操作所需的相对时间，这种做法便于综合比较解决同一问题的两种完全不同的算法。

**由于算法的时间复杂度考虑的只是对于问题规模 n 的增长率**，则在难以精确计算基本操作执行次数（或语句频度）的情况下，只需求出它关于 **n 的增长率** 或 **阶** 即可。例如，在下列程序段中：

```c
for  (i=2; i <= n; ++i)
    for (j=2; j <= i-1, ++j) { ++x; a[i][j] = x; }
```

完整代码见 `test1.c`

上述程序段中，公式 $n(n - 1)/2$ 的 $n$ 变成了 $n - 1$，所以公式变为 $(n - 1)(n - 2)/2$，语句 ++x 的执行次数关于 n 的增长率为 $n^2$ ,它是语句频度表达式 $(n-1)(n-2)/2$ 中增长最快的项，因为其他项 $-n$、$-2n$、$2$ 的增长速度都没它快

有的情况下，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同。例如在下列 **起泡排序** 的算法中：

```c
void bubble_sort(int a [], int n) {
    //将 a 中整数序列重新排列成自小至大有序的整数序列
    for (i = n - 1; change = TRUE; i > 1 && change; --i){
        change FALSE;
        for (j = 0; j < i; ++ j)
            i (a[j] > a [j + 1]) {a[j] <--> a[j + 1]; change = TRUE; }
    }
}// bubble-sort //这里 i > 1 貌似不对？改成了 i >= 1
```

“交换序列中相邻两个整数”为基本操作。

* 当 a 中初始序列为自小至大有序，基本操作的执行次数为0;
* 当初始序列为自大至小有序时，基本操作的执行次数为 $n(n - 1)/2$

> 共执行了: 4 + 3 + 2 + 1 = 10 次
> 这里认为该等差数列是从 0 开始的，则根据等差数列的前 n 项和公式: $S_n = a_1 * n + [n * (n - 1) * d] / 2$ 得 a_1 = 0, n = 5
> S_{5} = 0 + [n * (n - 1) * d] / 2 = [n * (n - 1) * d] / 2

完整代码见 `test2.c`

若算法中基本操作重复执行的次数随输入数据集不同，对这类算法的分析，一种解决的办法是计算它的平均值；即考虑它对所有可能的输人数据集的期望值，此时相应的时间复杂度为 **算法的平均时间复杂度**。

> 如假设 a 中初始输人数据可能出现 n！种的排列情况的概率相等，则起泡排序的平均时间复杂度 T_{arg}(n) = O (n^2)

然而，在很多情况下，各种输入数据集出现的概率难以确定，算法的平均时间复杂度也就难以确定。因此，另一种更可行也更常用的办法是讨论 **算法在最坏情况下的时间复杂度**，即分析最坏情况以估算算法执行时间的一个上界。

> 例如，上述起泡排序的最坏情况为 a 中初始序列为自大至小有序，则起泡排序算法在最坏情况下的时间复杂度为 T (n) =O (m2) 在本书以后各章中讨论的时间复杂度，除特别指明外，均指最坏情况下的时间复杂度

实践中我们可以把事前估算和事后统计两种办法结合起来使用。以两个矩阵相乘为例，若上机运行两个 10 × 10 的矩阵相乘，执行时间为 12ms，则由算法的时间复杂度 $T(n) = O(n^3)$ 可估算两个 31×31 的矩阵相乘所需时间大致为 $(31/10)^3 \cdot 12ms \approx 358ms$

#### 4. 算法的存储空间需求

类似于算法的时间复杂度，本书中以 **空间复杂度(space complexity)** 作为算法所需存储空间的量度，记作

$\qquad S(n) = O(f(n)) \qquad\qquad\qquad (1-6)$

其中 n 为问题的规模（或大小）。一个上机执行的程序除了需要存储空间来寄存本身所用指令、常数、变量和输入数据外，也需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的额外空间，否则应同时考虑输入本身所需空间（和输入数据的表示形式有关）。若额外空间相对于输入数据量来说是常数，则称 `此算法为原地工作`，第 10 章讨论的有些排序算法就属于这类。又如果所占空间量依赖于特定的输入，则除特别指明外，均按最坏情况来分析。
