
#### 1. 线性链表

从上一节的讨论中可见，线性表的顺序存储结构的特点是逻辑关系上相邻的两个元素在物理位置上也相邻，因此可以随机存取表中任一元素，它的存储位置可用一个简单、直观的公式来表示。

然而，从另一方面来看，这个特点也铸成了 线性表的**顺序存储结构**的弱点：在作插入或删除操作时，需移动大量元素

本节我们将讨论线性表的另一种表示方法 一 **链式存储结构**，由于它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的弱点，但同时也失去了顺序表可随机存取的优点。

##### 1. 基本概念

线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）

因此，为了表示每个数据元素 $a_i$ 与其直接后继数据元素 $a_{i+1}$ 之间的逻辑关系，对数据元素 a 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素 $a$，的存储映像，称为**结点（node）**，结点包括两个域：其中存储数据元素信息的域称为**数据域**；存储直接后继存储位置的域称为**指针域**。指针域中存储的信息称做 **指针** 或 **链**。

n 个结点 $(a_i (1 \leq i \leq n) 的存储映像)$ 链结成一个**链表**，即为线性表

$\qquad\left(a_{1}, a_{2}, \dots, a_{n}\right)$

的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。

##### 2. 单链表的结构

例如，图 2.5 所示为线性表

$\qquad$ (ZHAO, QIAN, SUN, LI, ZHOU, WU, ZHENG, WANG)

的线性链表存储结构，整个链表的存取必须从头指针开始进行，头指针指示链表中第一个结点（即第一个数据元素的存储映像）的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为“空”（NULL）

![](https://gitee.com/mayundaze/img_bed/raw/master/20200605115032.png)

用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此，这种存储结构为 **非顺序映像** 或 **链式映像**

通常我们把链表画成用箭头相链接的结点的序列，结点之间的箭头表示链域中的指针。如图 2.5 的线性链表可画成如图 2.6 所示的形式，这是因为在使用链表时，关心的只是它所表示的线性表中数据元素之间的逻辑顺序，而不是每个数据元素在存储器中的实际位置。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200605115343.png)

##### 3. 单链表节点的代码表示

由上述可见，单链表可由头指针惟一确定，在 C 语言中可用“结构指针”来描述（如下，LinkList 就是一个结构指针）

```cpp
//线性表的单链表存储结构
//使用 typedef 定义 LNode 的别名为 LNode，定义 LNode * 的别名为 LinkList
typedef struct LNode{
    ElemType data;
    struct LNode * next;
 } LNode, * LinkList;
```

假设 L 是 Linklist 型的变量，则 L 为单链表的头指针，它指向表中第一个结点。若 L 为“空”（L = NULL），则所表示的线性表为“空”表，其长度 n 为“零”。

有时，我们在单链表的第一个结点之前附设一个结点，称之为 **头结点**。头结点的数据域可以不存储任何信息，也可存储如线性表的长度等类的附加信息，头结点的指针域存储指向第一个结点的指针（即第一个元素结点的存储位置）。如图 2.7 (a）所示，此时，单链表的头指针指向头结点。若线性表为空表，则头结点的指针域为“空”，如图 2.7 (b）所示。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200605135545.png)

##### 4. 单链表查找元素

在线性表的顺序存储结构中，由于逻辑上相邻的两个元素在物理位置上紧邻，则每个元素的存储位置都可从线性表的起始位置计算得到。而在单链表中，任何两个元素的存储位置之间没有固定的联系。然而，每个元素的存储位置都包含在其直接前驱结点的信息之中。

假设 p 是指向线性表中第 i 个数据元素（结点 $a_i$) 的指针，则 p -> next 是指向第 i + 1 个数据元素（结点 $a_{i + 1}$) 的指针。换句话说，若 $p-> data = a$；，则 $p -> next ー> data = a_{i + 1}$。由此，在单链表中，取得第 i 个数据元素必须从头指针出发寻找，因此，单链表是非随机存取的存储结构。

#### 2. 示例

下面我们看函数 `GetElem` 在单链表中的实现:

###### 算法 2.8

```cpp
// L 为带头结点的单链表的头指针，指向头结点
// 当第 i 个元素存在时，其值赋给 e 并返回 0K，否则返回 ERROR
Status GetElem_L (LinkList L, int i, ElemType & e){

    LNode * p = L -> next; 
    int j = 1;                      //初始化，p 指向第一个结点，j 为计数器

    while (p && j < i){             //顺指针向后查找，直到 p 指向第 1 个元素或 p 为空
        p = p -> next;              //正常是 1 <= i <= n，如果 i > n 则通过 p 来结束循环，则该循环执行了 n 次后 p -> next 是 NULL，此时结束循环
        ++j;
    }

    if (! p || j > i)               //j = 1 <= i 才是合法的，如果 p 是空的则 
        return ERROR;               //第 1 个元素不存在
    
    e = p -> data;                  //取第 i 个元素的 data 赋值给 e
    
    return OK;

}// Getelem. L
```

##### 算法 2.8 的时间复杂度

算法 2.8 的基本操作是比较 j 和 i 并后移指针 p, while 循环体中的语句频度与被查元素在表中位置有关，若 $1 \leq i \leq n$，则频度为 i - 1, 否则频度为 n，因此算法 2.8 的时间复杂度为 $O(n)$

> n 个节点移动 n 次后（即 p -> next 执行多次后）p 的值是 NULL，从而结束 while 循环
