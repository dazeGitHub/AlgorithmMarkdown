
#### 线性链表的多项式的加法运算的实现

如何实现用这种线性链表表示的多项式的加法运算？

##### 1. 一元多项式相加的运算规则

1. 对于两个一元多项式中所有指数相同的项，对应系数相加，若其和不为零，则构成“和多项式”中的一项；
2. 对于两个一元多项式中所有指数不相同的项，则分别复抄到“和多项式”中去。

在此，按照上述抽象数据类型 Polynomial 中基本操作的定义，“和多项式”链表中的结点无需另生成，而应该从两个多项式的链表中摘取。

##### 2. “和多项式”链表加法运算的运算规则

假设指针 qa 和 qb 分别指向多项式 A 和多项式 B 中当前进行比较的某个结点，则比较两个结点中的指数项，有下列 3 种情况:

1. 指针 qa 所指结点的指数值 < 指针 qb 所指结点的指数值，则应摘取 qa 指针所指结点插入到“和多项式”链表中去；
2. 指针 qa 所指结点的指数值 > 指针 qb 所指结点的指数值，则应摘取指针 qb 所指结点插人到“和多项式”链表中去；
3. 指针 qa 所指结点的指数值 = 指针 qb 所指结点的指数值，则将两个结点中的系数相加，若和数不为零，则修改 qa 所指结点的系数值，同时释放 qb 所指结点；反之若和数为零，从多项式 A 的链表中删除相应结点，并释放指针 qa 和 qb 所指结点。

> 这个和多项式链表是将 多项式 A 链表 和 多项式 B 链表中的结点串起来了，而不是和顺序结构一样新开辟了个空间作为链表 C

例如，由图 2.17 中的两个链表表示的多项式相加得到的“和多项式”链表如图 2.18 所示，图中的长方框表示已被释放的结点。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200610161510.png)

上述多项式的相加过程和上一节讨论的归并两个有序表的过程极其类似，不同之处仅在于，后者在比较数据元素时只出现两种情况。因此，多项式相加的过程也完全可以利用线性链表的基本操作来完成

需要附加说明的是，在 2.3 节末定义的线性链表类型适用于一般的线性表，而 **表示一元多项式的应该是有序链表**。

有序链表的基本操作定义与线性链表有两处不同:

1. 一是 LocateElem 的职能不同
2. 二是需增加按有序关系进行插入的操作 OrderInsert

现说明如下：

```cpp
// 若升序链表 L 中存在与 e 满足判定函数 compare() 取值为 0 的元素，则 q 指示 L 中第一个值为 e 的结点的位置，并返回TRUE；
// 否则 q 指示第一个与 e 满足判定函数 compare() 取值 > 0 的元素的前驱的位置，并返回 FALSE（用于一元多项式）
Status LocateElemP(LinkList L, ElemType e, Position *q, int(*compare)(ElemType, ElemType));

//按有序判定函数 compare() 的约定，将值为 e 的结点插入到有序链表 L 的适当位置上
Status OrderInsert(LinkList *L, ElemType e, int(*comp)(ElemType, ElemType));
```
