
#### 串的块链存储表示

和线性表的链式存储结构相类似，也可采用链表方式存储串值。由于串结构的特殊性一结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。

例如，图 $4.2(a)$ 是结点大小为 4（即每个结点存放 4 个字符）的链表，图 $4.2(b)$ 是结点大小为 1 的链表。当结点大小大于 1 时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“#”或其他的非串值字符（通常“#”不属于串的字符集，是一个特殊的符号）

![](https://gitee.com/mayundaze/img_bed/raw/master/20200807105912.png)

为了便于进行串的操作，当以链表存储串值时，除头指针外还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串存储结构为 **块链结构**；说明如下：

```cpp
//======串的块链存储表示====== 
#define CHUNKSIZE 80                                    //可由用户定义的块大小
typedef struct Chunk{
    char ch[CHUNKSIZE]; 
    struct Chunk * next; 
}Chunk; 

typedef struct{
    Chunk * head, * tail;                               //串的头和尾指针
    int curlen;                                         //串的当前长度 
}LString
```

由于在一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。设尾指针的目的是为了便于进行联结操作，但应注意联结时需处理第个串尾的无效字符。

##### 存储密度

在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响着串处理的效率。在各种串的处理系统中，所处理的串往往很长或很多，例如，一本书的几百万个字符，情报资料的成千上万个条目。这要求我们考虑串值的存储密度。

存储密度可定义为:

$\qquad\begin{aligned} 存储密度 = \frac{串值所占的存储位}{实际分配的存储位} \end{aligned}$

显然，存储密度小（如结点大小为 1 时），运算处理方便，然而，存储占用量大。如果在串处理过程中需进行内、外存交换的话，则会因为内外存交换操作过多而影响处理的总效率。应该看到，串的字符集的大小也是一个重要因素。一般地，字符集小，则字符的机内编码就短，这也影响串值的存储方式的选取。

串值的链式存储结构对某些串操作，如联接操作等有一定方便之处，但总的说来不如另外两种存储结构灵活，它占用存储量大且操作复杂。此外，串值在链式存储结构时串操作的实现和线性表在链表存储结构中的操作类似，故在此不作详细讨论。
