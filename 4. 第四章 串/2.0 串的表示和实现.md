
### 串的表示和实现

如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。

串有 3 种机内表示方法，分别介绍如下。

#### 1. 定长顺序存储表示

类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述之。

```cpp
//------ 串的定长顺序存储表示 ------

#define MAXSTRLEN 255                           //用户可在 255 以内定义最大串长

typedef unsigned char SString[MAXSTRLEN + 1];   //0 号单元存放串的长度
```

串的实际长度可在这预定义长度的范围内随意，超过预定义长度的串值则被舍去，称之为“截断”。

##### 1. 串长的表示方法

对串长有两种表示方法：

1. 一是如上述定义描述的那样，以下标为 0 的数组分量存放串的实际长度，如 PASCAL 语言中的串类型采用这种表示方法；
2. 二是在串值后面加一个不计入串长的结束标记字符，如在有的 C 语言中以“0”表示串值的终结。此时的串长为隐含值，显然不便于进行某些串操作。

在这种存储结构表示时如何实现串的操作，下面以串联接和求子串为例讨论之。

##### 2. 串联接 Concat(&T, S1, S2)

假设 S1、S2 和 T 都是 SString 型的串变量，且串 T 是由串 S1 联结串 S2 得到的，即串 T 的值的前一段和串 S1 的值相等，串 T 的值的后一段和串 S2 的值相等，则只要进行相应的“串值复制”操作即可，只是需按前述约定，对超长部分实施“截断”操作。基于串 S1 和 S2 长度的不同情况，串 T 值的产生可能有如下 3 种情况：

$(1)$ $S1[0] + S2[0] <= MAXSTRLEN$，如图 $4.10(a)$ 所示，得到的串 T 是正确的结果；
$(2)$ $S1[0] < MAX-STRLEN$ 而 $S1[0] + S2[0] > MAXSTRLEN$，则将串 S2 的一部分截断，得到的串 T 只包含串 S2 的一个子串，如图 $4.1(b)$ 所示；
$(3)$ $S1[0] = MAXSTRLEN$，则得到的串 T 并非联接结果，而和串 S1 相等。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200806153120.png)

上述算法描述如算法 4.2 所示

###### 算法 4.2

```cpp
//用 T 返回由 S1 和 S2 联接而成的新串。若未截断，则返回 TRUE，否则 FALSE。
Status Concat(SString &T, SString S1, SString S2){

    if(S1[0] + S2[0] <= MAXSTRLEN){                             //未截断
        T[1..S1[0]] = S1[1..S1[0]];
        T[S1[0] + 1..S1[O] + S2[0]] = S2[1..S2[0]];             //赋值 S2 的值到 T 的 S1[0] + 1..S1[O] + S2[0] 位置处
        T[0] = S1[0] + S2[0]; 
        uncut = TRUE;
    }else if(S1[0] < MAXSTRLEN){                                //截断
        T[1..S1[0]] = S1[1..S1[0]];
        T[S1[0] + 1..MAXSTRLEN] = S2[1..MAXSTRLEN - S1[0]];     //将 S2 从 1..MAXSTRLEN(总长度) - S1[0](S1 的长度) 位置之后的值赋值给 T[S1[0] + 1..MAXSTRLEN] 位置处
        T[O] = MAXSTRLEN: 
        uncut = FALSE;
    }else{                                                      //截断（仅取 S1)  //S1[0] >= MAXSTRLEN
        T[0..MAXSTRLEN] = S1[O..MAXSTRLEN];                     //T[O] == S1[0] == MAXSTRLEN
        uncut = FALSE; 
    }
    return uncut;
}//Concat
```

##### 3. 求子串 Substring(& Sub, S, pos, len)

求子串的过程即为复制字符序列的过程，将串 S 中从第 pos 个字符开始长度为 len 的字符序列复制到串 Sub 中。显然，本操作不会有需截断的情况，但有可能产生用户给出的参数不符合操作的初始条件，当参数非法时，返回 ERROR。其算法描述如算法 4.3 所示。

###### 算法 4.3

```cpp
//用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。
//其中，1 <= pos <= StrLength(S）且 0 <= 1en <= StrLength(S) - pos + 1 
Status SubString (SString & Sub, SString S, int pos, int len){

    if(pos < 1 || pos > S [0] || len < 0 || len > S[0] - pos + 1)
        return ERROR;

    Sub[1..len] = S[pos..pos + len - 1];                          //pos 本身占了 len 的一个位置所以要 - 1
    Sub[0] = len;

    return OK;
}// SubString
```

综上两个操作可见，在顺序存储结构中，实现串操作的原操作为“字符序列的复制”，

操作的时间复杂度基于复制的字符序列的长度。另一操作特点是，如果在操作中出现串值序列的长度超过上界 MAXSTRLEN 时，约定用截尾法处理，这种情况不仅在求联接串时可能发生，在串的其他操作中，如插入、置换等也可能发生。克服这个弊病惟有不限定串长的最大长度，即动态分配串值的存储空间。