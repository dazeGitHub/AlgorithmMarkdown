
#### 串类型的定义

串（string)（或字符串）是由零个或多个字符组成的有限序列，一般记为

$\qquad s = { }^{\prime} a_{1} a_{2} \cdots a_{n}^{\prime} \quad(n \geqslant 0) \qquad\qquad\qquad (4-1)$

其中，s 是串的名，用单引号括起来的字符序列是串的值；$a_{i}(1 \leqslant i \leqslant n)$ 可以是字母、数字或其他字符；串中字符的数目 $n$ 称为串的长度。零个字符的串称为 **空串（null string）**，它的长度为零。

##### 1. 子串与主串

串中任意个连续的字符组成的子序列称为该串的 **子串**。包含子串的串相应地称为 **主串**。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。

###### 实例

例如，假设 a、b、c、d 为如下的 4 个串:

```c
    a = 'BEI' , b = 'JING' , c = 'BEIING' , d = 'BEI JING'
```

则它们的长度分别为 3、4、7 和 8; 并且 a 和 b 都是 c 和 d 的子串，a 在 c 和 d 中的位置都是 1, 而 b 在 c 中的位置是 4, 在 d 中的位置则是 5。

##### 2. 字符串的比较

称两个串是 **相等** 的，当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。例如上例中的串 a、b、c 和 d 彼此都不相等。

值得一提的是，串值必须用一对单引号括起来，但单引号本身不属于串，它的作用只是为了避免与变量名或数的常量混淆而已。

###### 实例

例如在程序设计语言中：

```c
x = '123'
```

则表明 $x$ 是一个串变量名，赋给它的值是字符序列 123。又如

```c
tsing = 'TSING'
```

中，tsing 是一个串变量名，而字符序列 TSING 是其值。

##### 3. 空格串与空串

在各种应用中，空格常常是串的字符集合中的一个元素，因而可以出现在其他字符中间。由一个或多个空格组成的串 '' 称为 **空格串**（blank string，请注意：此处不是空串）它的长度为串中空格字符的个数。为了清楚起见，以后我们用符号“$\varnothing$”来表示 **“空串”**。

##### 4. 串的逻辑结构

串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。然而，串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象，例如在线性表中查找某个元素、求取某个元素、在某个位置上插入一个元素和删除个元素等；而在串的基本操作中，通常以“串的整体”作为操作对象，例如在串中查找某个子串、求取一个子串、在串的某个位置上插入ー个子串以及删除一个子串等。

##### 5. 串的抽象数据类型

串的抽象数据类型的定义如下：

###### 数据对象

$\qquad \mathrm{D}=\left\{\mathrm{a}_{\mathrm{i}} \mid \mathrm{a}_{\mathrm{i}} \in \text { CharacterSet }, \mathrm{i}=1,2, \cdots, \mathrm{n}, \mathrm{n} \geqslant 0\right\}$

###### 数据关系

$\qquad R_{1}=\left\{<a_{i-1}, a_{i}>\mid a_{i-1}, a_{i} \in D, i=2, \cdots, n\right\}$

###### 基本操作

```cpp
ADT String{

    // 初始条件：chars 是字符串常量。
    // 操作结果：生成一个其值等于 chars 的串
    StrAssign(&T, chars)

    // 初始条件：串 S 存在。
    // 操作结果：由串 S 复制得串 T。
    StrCopy(&T, S)

    // 初始条件：串 S 存在。
    // 操作结果：若 S 为空串，则返回 TRUE，否则返回 FALSE。
    StrKmpty(S)

    // 初始条件：串 S 和存在。
    // 操作结果：若 S > T，则返回值 > 0; 若 S = T，则返回值 = 0; 若 S < T，则返回值 < 0。
    StrCompare(S, T)

    // 初始条件：串 S 存在。
    // 操作结果：返回 S 的元素个数，称为串的长度。
    StrLength(S)

    // 初始条件：串 S 存在。
    // 操作结果：将 S 清为空串。
    ClearString(&S)

    // 初始条件：串 S1 和 S2 存在。
    // 操作结果：用 T 返回由 S1 和 S2 联接而成的新串。
    Concat(&T, S1, S2)

    // 初始条件：串 S 存在，1 <= pos <= StrLength(S）且 0 <= len <= StrLength(S) - pos + 1
    // 操作结果：用 Sub 返回串 S 的第 pos 个字符起长度为 1en 的子串。
    SubString(&Sub, S, pos, len)

    // 初始条件：串 S 和 T 存在，T 是非空串，1 <= pos <= StrLength(S)
    // 操作结果：若主串 S 中存在和串 T 值相同的子串，则返回它在主串 S 中第 pos 个字符之后第一次出现的位置；否则函数值为 0。
    Index(S, T, pos)

    // 初始条件：串 S, T 和 V 存在，T 是非空串
    // 操作结果：用 V 替换主串 S 中出现的所有与 T 相等的不重叠的子串。
    Replace(&S, T, V)

    // 初始条件：串 S 和 T 存在，1 <= poss <= StrLength(S) + 1。
    // 操作结果：在串 S 的第 pos 个字符之前插入串 T
    StrInsert(&S, pos, T)

    // 初始条件：串 S 存在，1 <= pos <= StrLength(S) - len + 1。
    // 操作结果：从串 S 中删除第 pos 个字符起长度为 len 的子串。
    StrDelete(&S, pos, len)

    // 初始条件：串 S 存在
    // 操作结果：串 S 被销毁
    DestroyString(&S)

}ADI String
```

对于串的基本操作集可以有不同的定义方法，读者在使用高级程序设计语言中的串类型时，应以该语言的参考手册为准。

##### 6. 串基本操作的实现

在上述抽象数据类型定义的 13 种操作中，串赋值 StrAssign、串比较 StrCompare、求串长 StrLength、串联接 Concat 以及求子串 SubString 5 种操作构成串类型的最小操作子集。即这些操作不可能利用其他串操作来实现，反之，其他串操作（除串清除 ClearString 和串销毁 DestroyString 外）均可在这个最小操作子集上实现。

例如，可利用判等、求串长和求子串等操作实现定位函数 `Index(S,T,pos)`。

算法的基本思想: 在主串 $S$ 中取从第 $i$ (i 的初值为 pos）个字符起、长度和串 $T$ 相等的子串和串 $T$ 比较，若相等，则求得函数值为 $i$，否则 $i$ 值增 1 直至串 $S$ 中不存在和串 $T$ 相等的子串为止，如算法 4.1 所示。

###### 算法 4.1

```cpp
//T 为非空串。若主串 S 中第 pos 个字符之后存在与 T 相等的子串，则返回第一个这样的子串在 S 中的位置，否则返回 0
Int Index (String S, String T, Int pos){

    if(pos > 0){
        n = StrLength(S);
        m = StrLength(T);
        i = pos;

        while(i <= n - m + 1){
            SubString(sub, S, i, m);            //用 sub 返回串 S 的返回第 i 个字符起长度为 m 个字符串，因为是第 i 个字符而不是索引，所以是 i <= n - m + 1
            if(StrCompare(sub, T) != 0)
                ++ i;
            else 
                return i;                       //返子串在主串中的位置
        }//while
    }//if

    return 0;                                   //S 中不存在与相等的子串
}// Index
```
