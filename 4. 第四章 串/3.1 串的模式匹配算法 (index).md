
#### 串的匹配模式算法

##### 1. 求子串位置的定位函数 Index(S, T, pos)

子串的定位操作通常称做 **串的模式匹配**（其中 T 称为模式串），是各种串处理系统中最重要的操作之一。在 4.1 节中曾借用串的其他基本操作给出了定位函数的一种算法根据算法 4.1 的基本思想，采用定长顺序存储结构，可以写出不依赖于其他串操作的匹配算法，如算法 4.5 所示。

###### 算法 4.5

```cpp
//返回子串 T 在主串 S 中第 pos 个字符之后的位置。若不存在，则函数值为 0。
//其中，T 非空，1 <= pos <= StrLength(S)
Int Index(SString S, SString T, int pos){
    
    i = pos;
    j = 1;

    while(i <= S[O] && j <= T[O]){
        if(S[i] == T[j]) {                          //继续比较后继字符
            ++i; 
            ++j; 
        }else{
            i = i - j + 2; 
            j = 1;                                  //指针后退重新开始匹配
        }
    }

    if(j > T[0]) 
        return i - T[0];

    else return 0;

}//Index
```

在算法 4.5 的函数过程中，分别利用计数指针 i 和 j 指示主串 S 和模式串 T 中当前正待比较的字符位置。

算法的基本思想是：从主串 S 的第 pos 个字符起和模式的第一个字符比较之，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起再重新和模式的字符比较之。依次类推，直至模式 T 中的每个字符依次和主串 S 中的一个连续的字符序列相等，则称匹配成功，函数值为和模式 T 中第一个字符相等的字符在主串 S 中的序号，否则称匹配不成功，函数值为零。

图 4.3 展示了模式 T='abac' 和主串 S 的匹配过程（pos=1):

![](https://gitee.com/mayundaze/img_bed/raw/master/20200807143156.png)

##### 2. 算法 4.5 复杂度分析

算法 4.5 的匹配过程易于理解，且在某些应用场合，如文本编辑等，效率也较高，例如，在检査模式 `STING` 是否存在于下列主串中时，

`A STRING SEARCHING EXAMPLE CONSISTING OF SIMPLE TEXT`

上述算法中的 WHILE 循环次数（即进行单个字符比较的次数）为 41, 恰好为 `(Index + T[0] - 1) + 4`, 这就是说，除了主串中呈黑体的 4 个字符，每个字符比较了两次以外，其他字符均只和模式进行一次比较。在这种情况下，此算法的时间复杂度为 $O (n + m)$。其中 $n$ 和 $m$ 分别为主串和模式的长度。

然而，在有些情况下，该算法的效率却很低。例如，当模式串为 `0000001`, 而主串为 `000000000000000000000000000 00000000000000000000000001` 时，由于模式中前 7 个字符均为“0”，又，主串中前 52 个字符均为“0”，每趟比较都在模式的最后一个字符出现不等，此时需将指针回溯到 $i - 6$ 的位置上，并从模式的第一个字符开始重新比较，整个匹配过程中指针 i 需回溯 45 次，则 WHILE 循环次数为 $46 * 8 (index * m)$。

可见，算法 4.5 在最坏情况下的时间复杂度为 $O(n * m)$。这种情况在只有 0、1 两种字符的文本串处理中经常出现，因为在主申中可能存在多个和模式申“部分匹配”的子串，因而引起指针 i 的多次回溯。`01` 申可以用在许多应用之中。

比如，一些计算机的图形显示就是把画面表示为一个 `01` 串，一页书就是一个几百万个 0 和 1 组成的串。在二进位计算机上实际处理的都是 `01` 串个字符的 ASCII 码也可以看成是 8 个二进位的 01 串。包括汉字存储在计算机中处理时也是作为一个 01 串和其他的字符串一样看待。因此在下一节，我们将介绍另一种较好的模式匹配算法。
