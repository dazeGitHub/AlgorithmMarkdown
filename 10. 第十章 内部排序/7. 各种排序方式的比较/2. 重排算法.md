
#### 重排算法

本章讨论的多数排序算法是在顺序存储结构上实现的，因此在排序过程中需进行大量记录的移动。当记录很大（即每个记录所占空间较多）时，时间耗费很大，此时可采用静态链表作存储结构。如表插入排序、链式基数排序，以修改指针代替移动记录。但是，有的排序方法，如快速排序和堆排序，无法实现表排序。在这种情况下可以进行“地址排序”，即另设一个地址向量指示相应记录；同时在排序过程中不移动记录而移动地址向量中相应分量的内容。

例如对图 $10.15(a)$ 所示记录序列进行地址排序时，可附设向量 $adr(1:8)$。在开始排序之前令 $adr[i] := i$，凡在排序过程中需进行 $r[i] := r[j]$ 的操作时，均以 $adr[i] := adr[j]$ 代替，则在排序结束之后，地址向量中的值指示排序后的记录的次序，$r[adr[1]]$ 为关键字最小的记录，$r[adr[8]]$ 为关键字最大的记录，如图 $10.15(b)$ 所示。最后在需要时可根据 $adr$ 的值重排记录的物理位置。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200805101145.png)

重排算法如下：

1. 从 $i = 1$ 起依次检査每个分量位置上的记录是否正确到位。若 $adr[i] = i$，则 $r[i]$ 中恰为第 $i$ 个最小关键字的记录，该位置上的记录不需要调整；若 $adr[i] = k \neq i$，则说明 $r[k]$ 中记录是第 $i$ 个最小关键字的记录，应在暂存记录 $r[i]$ 之后将 $r[k]$ 中记录移至 $r[i]$ 的位置上 ($r[i]$ 的位置指的是 $r$ 数组中第 $i$ 个分量，下同)。

2. 类似地，若 $adr[k] \neq k$，则应将 $r[adr[k]]$ 中记录移至 $r[k]$ 的位置上。依次类推，直至找到某个值 $j = adr[adr[\cdots adr[k] \cdots]]$，等式 $adr[j] = i$ 成立时，将暂存记录移至 $r[j]$ 的位置上。至此完成一个调整记录位置的小循环。

> 例如图 10.15 的例子，由于图 $10.15(b)$ 中 $adr[1] = 6$, 则在暂存 $R(49)$ 以后，需将 $R(13)$ 从 $r[6]$ 的位置移至 $r[1]$ 的位置。又，因为 $adr[6] = 2$, 则应将 $R(65)$ 从 $r[2]$ 的位置移至 $r[6]$ 的位置。同理，将 $R (27)$ 移至 $r[2]$ 的位置，此时，因 $adr[4] = 1$, 则 $R(49)$ 应置入 $r[4]$ 的位置上。完成上述调整后的记录及地址向量的状态如图 $10.15(c)$ 所示。算法 10.18 即为上述重排记录的算法。

###### 算法 10.18

```cpp
void Rearrange (SqList & L, int adr[]){
    //adr 给出顺序表 L 的有序次序，即 L.r[adr[i]] 是第 i 小的记录。
    //本算法按 adr 重排 L.r，使其有序
    for(i = 1; i < L.length; ++ i){
        if (adr[i] != i){
            j = i;
            L.r[0] = L.r[i];        //暂存记录 L.r[i]
            while(adr[j] != i){     //调整 L.r[adr[j]] 的记录到位直到 adr[j] = i 为止
                k = adr[j]; 
                L.r[j] = L.r[k];
                adr[j] = j; 
                j = k;
            }
            L.r[j] = L.r[0]; 
            adr[j] = j;             //记录按序到位
        }
    }
}// Rearrange
```

从上述算法容易看出，除了在每个小循环中要暂存一次记录外，所有记录均一次移动到位。而每个小循环至少移动两个记录,则这样的小循环至多有 $\lfloor n / 2\rfloor$ 个,所以重排记录的算法中至多移动记录 $\lfloor 3 n / 2\rfloor$ 次
