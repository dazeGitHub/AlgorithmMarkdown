
#### 概述

##### 1. 排序的定义

排序（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。

从第 9 章的讨论中容易看出，为了査找方便，通常希望计算机中的表是按关键字有序的。因为有序的顺序表可以采用查找效率较高的折半查找法，其平均査找长度为 $log_2 (n + 1) - 1$, 而无序的顺序表只能进行顺序查找,其平均査找长度为 $(n + 1)/2$。又如建造树表（无论是二叉排序树或 B 树）的过程本身就是一个排序的过程。因此，学习和研究各种排序方法是计算机工作者的重要课题之一。

为了便于讨论，在此首先要对排序下一个确切的定义：

假设含 $n$ 个记录的序列为:

$\qquad\left\{R_{1}, R_{2}, \cdots, R_{n}\right\} \qquad\qquad\qquad (10 - 1)$

其相应的关键字序列为

$\qquad\left\{K_{1}, K_{2}, \cdots, K_{n}\right\}$

需确定 $1,2,\cdots,n$ 的一种排列 $p_{1}, p_{2}, \cdots, p_{n}$，使其相应的关键字满足如下的非递减（或非递增，若将式（10-2) 中的 “≤” 号改为 “≥” 号，则满足非递增关系）关系

$\qquad K_{p_{1}} \leqslant K_{p_{2}} \leqslant \cdots \leqslant K_{p_{n}} \qquad\qquad (10 - 2)$

即使式 $(10 - 1)$ 的序列成为一个按关键字有序的序列

$\qquad \left\{R_{p_{1}}, R_{p_{2}}, \cdots, R_{p_{n}}\right\} \qquad\qquad\quad\;\; (10 - 3)$

这样一种操作称为排序。

##### 2. 排序的稳定性

上述排序定义中的关键字 $K_i$ 可以是记录 $R_i(i = 1,2,\cdots,m)$ 的主关键字，也可以是记录 $R_i$ 的次关键字，甚至是若干数据项的组合。

* 若 $K_i$ 是主关键字，则任何一个记录的无序序列经排序后得到的结果是性一的；
* 若 $K_i$ 是次关键字，则排序的结果不惟一，因为待排序的记录序列中可能存在两个或两个以上关键字相等的记录。假设 $K_i = K_j (1 \leq i \leq n, 1 \leq j \leq n, i \neq j)$，且在排序前的序列中 $R_i$ 领先于 $R_j$（即 $i < j$）。若在排序后的序列中 $R_i$ 仍领先于 $R_j$，则称所用的 **排序方法是稳定的**；反之，若可能使排序后的序列中 $R_j$ 领先于 $R_i$, 则称所用的 **排序方法是不稳定的**（对不稳定的排序方法，只要举出一组关键字的实例说明它的不稳定性即可）。

##### 3. 排序的种类

由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：

* 一类是内部排序，指的是待排序记录存放在计算机随机存储器中进行的排序过程；
* 另一类是外部排序，指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。

本章先集中讨论内部排序，将在下一章中讨论外部排序。

###### 内部排序的几种方法

内部排序的方法很多，但就其全面性能而言，很难提出一种被认为是最好的方法，每种方法都有各自的优缺点，适合在不同的环境（如记录的初始排列状态等）下使用。如果按排序过程中依据的不同原则对内部排序方法进行分类，则大致可分为 `插入排序`、`交换排序`、`选择排序`、`归并排序` 和 `计数排序` 等五类；

如果按内部排序过程中所需的工作量来区分，则可分为 3 类：

$(1)$ 简单的排序方法，其时间复杂度为 $O(n^2)$; 
$(2)$ 先进的排序方法，其时间复杂度为 $O(nlogn)$;
$(3)$ 基数排序，其时间复杂度为 $O(d \cdot m)$。

本章仅就每一类介绍两个典型算法，有兴趣了解更多算法的读者可阅读 D.E. 克努特著《计算机程序设计技巧》（第三卷，排序和査找）。读者在学习本章内容时应注意，除了掌握算法本身以外，更重要的是了解该算法在进行排序时所依据的原则，以利于学习和创造更加新的算法。

##### 4. 排序的基本操作

通常，在排序的过程中需进行下列两种基本操作：

$(1)$ 比较两个关键字的大小。
$(2)$ 将记录从一个位置移动至另一个位置。

前一个操作对大多数排序方法来说都是必要的，而后一个操作可以通过改变记录的存储方式来予以避免。

##### 5. 记录序列的存储方式

待排序的记录序列可有下列 3 种存储方式：

$(1)$ 待排序的一组记录存放在地址连续的一组存储单元上。它类似于线性表的顺序存储结构，在序列中相邻的两个记录 $R_j$ 和 $R_{j + 1} (j = 1, 2, \cdots,n - 1)$，它们的存储位置也相邻。在这种存储方式中，记录之间的次序关系由其存储位置决定，则实现排序必须借助移动记录；
$(2)$ 一组待排序记录存放在静态链表中（因为在排序过程中，只是改变记录之间的次序关系，而不进行插入、删除操作，且在排序结束时尚需调整记录，故采用静态链表），记录之间的次序关系由指针指示，则实现排序不需要移动记录，仅需修改指针即可；
$(3)$ 待排序记录本身存储在一组地址连续的存储单元内，同时另设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向量中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置。

在第二种存储方式下实现的排序又称（链）表排序，在第三种存储方式下实现的排序又称地址排序。

##### 6. 待排记录的数据类型

在本章的讨论中，设待排序的一组记录以上述第一种方式存储，且为了讨论方便起见，设记录的关键字均为整数。即在以后讨论的大部分算法中，待排记录的数据类型设为:

```cpp
#define MAXSIZE 20          //ー个用作示例的小顺序表的最大长度 
typedef int KeyType;        //定义关键字类型为整数类型 

typedef struct{
    KeyType key;            //关键字项 
    InforType otherinfo;    //其他数据项 
}RedType;                   //记录类型 

typedef struct{
    RedType r[MAXSIZE + 1]; //r[0] 闲置或用作哨兵单元
    int length;             //顺序表长度
}SqList;                    //顺序表类型
```
