
从上一节的讨论中可见，直接插入排序算法简便，且容易实现。当待排序记录的数量 $n$ 很小时，这是一种很好的排序方法。但是，通常待排序序列中的记录数量 $n$ 很大，则不宜采用直接插人排序。由此需要讨论改进的办法。在直接插入排序的基础上，从减少“比较”和“移动”这两种操作的次数着眼，可得下列各种插入排序的方法。

#### 1. 折半插入排序

由于插入排序的基本操作是在一个有序表中进行査找和插入，则从 9.1 节的讨论中可知，这个 “查找” 操作可利用 “折半査找” 来实现，由此进行的插人排序称之为折半插入排序（Binary Insertion Sort），其算法如算法 10.2 所示

###### 算法 10.2

```cpp
//对顺序表 L 作折半插入排序。
void BInsertSort(Sqlist & L){

    for (i = 2; i <= L.length; ++i){

        L.r[0] = L.r[i];                        //将 L.r[i] 暂存到 L.r[0]
        low = 1; 
        high = i - 1;

        while (low <= high){                    //在 r[low..high] 中折半查找有序插入的位置

            m = (low + high) /2;                //折半

            if (LT(L.r[0].key, L.r[m].key)) 
                high = m - 1;                   //插入点在低半区
            else
                low = m + 1;                    //插入点在高半区

        }// while

        for (j = i - 1; j >= high + 1; --j)
            L.r[j + 1] = L.r[j];                //记录后移

        L.r[high + 1] = L.r[0];                 //插人
    }// for
}// BInsertSort
```

从算法 10.2 容易看出，折半插入排序所需附加存储空间和直接插入排序相同，从时间上比较，折半插人排序仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为 $O(n^2)$。
