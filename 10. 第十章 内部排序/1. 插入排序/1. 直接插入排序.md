
#### 直接插入排序

直接插入排序（Straight Insertion Sort）是一种最简单的排序方法，它的基本操作是将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。

##### 1. 排序实例

例如，已知待排序的一组记录的初始排列如下所示：

$\qquad R(49), R(38), R(65), R(97), R(76), R(13), R(27), R(\overline{49}), \cdots \quad(10-4)$

假设在排序过程中，前 4 个记录已按关键字递增的次序重新排列，构成一个含 4 个记录的有序序列

$\qquad \{R(38), R(49), R(65), R(97)\} \qquad\qquad\qquad\qquad\qquad\qquad\qquad (10-5)$

现要将式 $(10-4)$ 中第 5 个（即关键字为 76 的）记录插入上述序列，以得到一个新的含 5 个记录的有序序列，则首先要在式 $(10-5)$ 的序列中进行査找以确定 $R(76)$ 所应插入的位置，然后进行插入。假设从 $R(97)$ 起向左进行顺序査找，由于 $65  < 76 < 97$, 则 $R(76)$ 应插入在 $R(65)$ 和 $R(97)$ 之间，从而得到下列新的有序序列

$\qquad \{R(38), R(49), R(65), R(76), R(97)\} \qquad\qquad\qquad\qquad\qquad\quad\; (10-6)$

称从式（10-5) 到式（10-6) 的过程为一趟 直接插入排序。

一般情况下，第 $i$ 趙直接插入排序的操作为：在含有 $i - 1$ 个记录的有序子序列 $r[1..i - 1]$ 中插入一个记录 $r[i]$ 后，变成含有 $i$ 个记录的有序子序列 $r[1..i]$；并且，和顺序查找类似，为了在查找插入位置的过程中避免数组下标出界，在 $r[O]$ 处设置监视哨。在自 $i - 1$ 起往前搜索的过程中，可以同时后移记录。

##### 2. 排序过程

整个排序过程为进行 $n - 1$ 趟插入，即：

1. 先将序列中的第 1 个记录看成是一个有序的子序列
2. 然后从第 2 个记录起逐个进行插入，直至整个序列变成按关键字非递减有序序列为止。

其算法如算法 10.1 所示

###### 算法 10.1

```cpp
void InsertSort (Sqlist & L){
    //对顺序表工作直接插入排序。
    for(i = 2; i <= L.length; ++i){
        if(LT(L.r[i].key, L.r[i - 1].key)){                     //“<”，需将 L.r[i] 插入有序子表
            L.r[0] = L.r[i];                                    //复制为哨兵
            L.r[i] = L.r[i - 1];
            for(j = i - 2; LT(L.r[0].key,L.r[j].key); -- j);
                L.r[j + 1] = L.r[j];                            //记录后移
            L.r[j + 1] = L.r[O];                                //插入到正确位置
        }
    }
}//InsertSort 
```

##### 3. 排序图解

以式（10-4) 中关键字为例，按照算法 10.1 进行直接插入排序的过程如图 10.1 所示（为简便起见，图中省略记录 R 的符号，而只列其关键字）:

![](https://gitee.com/mayundaze/img_bed/raw/master/20200729164829.png)

##### 4. 排序复杂度分析

从上面的叙述可见，直接插入排序的算法简洁，容易实现，那么它的效率如何呢？

###### 空间复杂度

从空间来看，它只需要一个记录的辅助空间。

###### 时间复杂度

从时间来看，排序的基本操作为：`比较两个关键字的大小` 和 `移动记录`。

先分析一趟插入排序的情况: 算法 10.1 中里层的 for 循环的次数取决于待插记录的关键字与前 $i - 1$ 个记录的关键字之间的关系。

若 $L.r[i].key < L.r[1].key$，则内循环中，待插记录的关键字需与有序子序列 $L.r[1.. i - 1]$ 中 $i$ 个记录的关键字和监视哨中的关键字进行比较，并将 $L.r[1..i - 1]$ 中 $i - 1$ 个记录后移。则在整个排序过程（进行 $n - 1$ 趟插入排序）中:

当待排序列中记录按关键字非递减有序排列（以下称之为“正序”）时:

* 所需进行关键字间比较的次数达最小值 $n - 1$（即 $\begin{aligned} \sum_{i=2}^{n} 1 \end{aligned}$)，记录不需移动；

当待排序列中记录按关键字非递增有序排列 (以下称之为“逆序”) 时:

* 总的比较次数达最大值 $(n + 2)(n - 1)/2$ (即 $\begin{aligned}\sum_{i=2}^{n} i \end{aligned}$), 记录移动的次数也达最大值 $(n + 4)(n - 1) / 2$ (即 $\begin{aligned}\sum_{i=2}^{n} (i + 1)\end{aligned}$ )。

若待排序记录是随机的，即待排序列中的记录可能出现的各种排列的概率相同时:

* 则可取上述最小值和最大值的平均值, 作为直接插人排序时所需进行关键字间的比较次数和移动记录的次数，约为 $n^2 / 4$。由此，直接插入排序的时间复杂度为 $O(n^2)$。

> $\begin{aligned} \sum_{i=2}^{n} \end{aligned}$ 可看做从 $2$ 到 $n$ 公差为 0 的等差数列，$\begin{aligned} S_n = \frac{n (a_1 + a_n)}{2}  \end{aligned}$，则有:
> $\qquad\begin{aligned} \sum_{i=2}^{n} 1 = \frac{(n - 1) (1 + 1)}{2} = n - 1\end{aligned}$
>
> $\qquad\begin{aligned} \sum_{i=2}^{n} i = \frac{(n - 1) (2 + n)}{2} = \frac{(n + 2)(n - 1)}{2} \end{aligned}$
>
> $\qquad\begin{aligned} \sum_{i=2}^{n} (i + 1) = \frac{(n - 1)(2 + 1 + n + 1)}{2} = \frac{(n + 4)(n - 1)}{2} \end{aligned}$

