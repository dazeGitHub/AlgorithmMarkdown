
#### 2-路插入排序

2-路插入排序是在折半插人排序的基础上再改进之，其目的是减少排序过程中移动记录的次数，但为此需要 n 个记录的辅助空间。

具体做法是：

1. 另设一个和 $L.r$ 同类型的数组 $d$，首先将 $L.r[1]$ 赋值给 $d[1]$，并将 $d[1]$ 看成是在排好序的序列中处于中间位置的记录。
2. 然后从 $L.r$ 中第 2 个记录起依次插入到 $d[1]$ 之前或之后的有序序列中。先将待插记录的关键字和 $d[1]$ 的关键字进行比较，若 $L.r[i].key < d[1].key$，则将 $L.r[i]$ 插入到 $d[1]$ 之前的有序表中。反之，则将 $L.r[i]$ 插人到 $d[l]$ 之后的有序表中。
3. 在实现算法时，可将 $d$ 看成是一个循环向量，并设两个指针 $first$ 和 $final$ 分别指示排序过程中得到的有序序列中的第一个记录和最后一个记录在 $d$ 中的位置。具体算法留作习题由读者自己写出。

仍以式 $(10-4)$ 中的关键字为例，进行 2-路插入排序的过程如图 10.2 所示。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200729175631.png)

> 如图，先把 L.r[1] 即 38 看成是在排好序的序列中处于中间位置的记录，再插入的 49 比 38 大，所以放到左边 (final 表示 38 之后的有序表)，后边的 65、97、76 依次比 38 大，则都放入左边的有序表，之后的 13 比 38 小，则放到右边（first 表示 38 之前的有序表），依次类推，直到把数组 d 插满

在 2-路插入排序 中,移动记录的次数约为 $n^2 / 8$。因此, 2-路插入排序只能减少移动记录的次数，而不能绝对避免移动记录。并且，当 $L.r[1]$ 是待排序记录中关键字最小或最大的记录时，2-路插入排序就完全失去它的优越性。因此，若希望在排序过程中不移动记录，只有改变存储结构，进行表插入排序。
