
#### 表插入排序

假设以上述说明的静态链表类型作为待排记录序列的存储结构，并且，为了插入方便起见，设数组中下标为“0”的分量为表头结点，并令表头结点记录的关键字取最大整数 MAXINT。

```cpp
#define SIZE 100        //静态链表容量 
typedef struct{
    RcdType rc;         //记录项
    int next            //指针项
}SLNode;                //表结点类型 

typedef struct{
    SLNode r[SIZE];     //0 号单元为表头结点 
    int length;         //链表当前长度 
}SLinkListType;         //静态链表类型
```

##### 表插入排序的过程

1. 首先将静态链表中数组下标为“1”的分量（结点）和表头结点构成一个循环链表
2. 然后依次将下标为“2”至“n”的分量（结点）按记录关键字非递减有序插入到循环链表中。

$\quad$ 仍以式（10-4) 中的关键字为例:

$\qquad R(49), R(38), R(65), R(97), R(76), R(13), R(27), R(\overline{49}), \cdots \quad(10-4)$

$\quad$ 表插入排序的过程如图 10.3 所示（图中省略记录的其他数据项）

![](https://gitee.com/mayundaze/img_bed/raw/master/20200730111550.png)

> 数组下标为 0 的结点的 next 域指向 key 最小的结点，然后 key 域最大的结点的 next 域指向数组下标为 0 的结点。
> 例如 `i = 4` 时 MAXINT 的 next 域是 2，指向索引为 2 的结点（key 域为 38），然后 key 域为 38 的结点依次向后指，直到 key 最大为 97 的结点，而 key 为 97 的结点的 next 域也指向了索引 0（即 MAXINT），正好构成了循环链表

从表插入排序的过程可见，表插入排序的基本操作仍是将一个记录插入到已排好序的有序表中。和直接插入排序相比，不同之处仅是以修改 $2n$ 次指针值代替移动记录，排序过程中所需进行的关键字间的比较次数相同。因此，表插入排序的时间复杂度仍是 $O(n^2)$。

另一方面，表插入排序的结果只是求得一个有序链表，则只能对它进行顺序査找，不能进行随机査找，为了能实现有序表的折半查找，尚需对记录进行重新排列。

##### 重排记录的做法

重排记录的做法是：顺序扫描有序链表，将链表中第 $i$ 个结点移动至数组的第 i 个分量中。

例如，图 $10.4(a)$ 是经表插入排序后得到的有序链表 SL。根据头结点中指针域的指示，链表的第一个结点，即关键字最小的结点是数组中下标为 6 的分量，其中记录应移至数组的第一个分量中，则将 $SL.r[1]$ 和 $SL.r[6]$ 互换，并且为了不中断静态链表中的“链”，即在继续顺链扫描时仍能找到互换之前在 $SL.r[1]$ 中的结点，令互换之后的 $SL.r[1]$ 中指针域的值改为“6”（见图 $10.4(b)$ ）。推广至一般情况，若第 i 个最小关键字的结点是数组中下标为 $p$ 且 $p > i$ 的分量，则互换 $SL.r[i]$ 和 $SL.r[p]$，且令 $SL.r[i]$ 中指针域的值改为 $p$；由于此时数组中所有小于 $i$ 的分量中已是“到位”的记录，则当 $p < i$ 时，应顺链继续査找直到 $p \geq i$ 为止。图 10.4 所示为重排记录的全部过程。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200730113239.png)

###### 算法 10.3

```cpp
//根据静态链表 SL 中各结点的指针值调整记录位置，使得 SL 中记录按关键字非递减减有序顺序排列 
void Arrange (SLinkListType & SL){
    p = SL.r[O].next;                   //p 指示第一个记录的当前位置
    for(i = 1; i < SL.length; ++i){     //SL.r[1 .. i - 1] 中记录已按关键字有序排列，第 i 个记录在 SL 中的当前位置应不小于 i 
        whi1e(p < i)
            p = SL.r[p].next;           //找到第 i 个记录，并用 p 指示其在 SL 中当前位置
        q = SL.r[p].next;               //q 指示尚未调整的表尾
        if (p != i) {
            SL.r[p] <--> SL.r[i];       //交换记录，使第 i 个记录到位
            SL.r[i].next = p;           //指向被移走的记录，使得以后可由 while 循环找回
        }
        p = q;                          //p 指示尚未调整的表尾，为找第 i + 1 个记录作准备 
    }
}// Arrange
```

算法 10.3 描述了上述重排记录的过程。容易看出，在重排记录的过程中，最坏情况是每个记录到位都必须进行一次记录的交换，即 3 次移动记录，所以重排记录至多需进行 $3(n - 1)$ 次记录的移动，它并不增加表插入排序的时间复杂度。
