
#### 简单排序

##### 1. 基本思想

选择排序（Selection Sort）的基本思想是：每一趟在 $n - i + 1 (i = 1,2, \cdots, n - 1)$ 个记录中选取关键字最小的记录作为有序序列中第 i 个记录。其中最简单且为读者最熟悉的是简单选择排序（Simple Selection Sort）。

##### 2. 操作步骤

一趟简单选择排序的操作为：通过 $n - i$ 次关键字间的比较，从 $n - i + 1$ 个记录中选出关键字最小的记录，并和第 $i(1 \leqslant i \leqslant n)$ 个记录交换之。

显然，对 $L.r[1..n]$ 中记录进行简单选择排序的算法为：令 $i$ 从 1 至 $n - 1$, 进行 $n$ 趟选择操作，如算法 10.9 所示。容易看出，简单选择排序过程中，所需进行记录移动的操作次数较少，其最小值为“0”，最大值为 $3(n - 1)$。然而, 无论记录的初始排列如何, 所需 进行的关键字间的比较次数相同，均为 $n(n - 1)/2$。因此，总的时间复杂度也是 $O(n^2)$。

###### 算法 10.9

```cpp
void SelectSort (Sqlist &L){
    //对顺序表 L 作简单选择排序。
    for(i = 1: i < L.length: ++ i){     //选择第 i 小的记录，并交换到位
        j = SelectMinKey(L, i);         //在 L.r[i .. L.length] 中选择 key 最小的记录
        if (i != j) 
            L.r[i] <--> L.r[j];         //与第 i 个记录交换
    }
}// SelectSort
```

##### 3. 简单排序的改进

那么，能否加以改进呢？

从上述可见，选择排序的主要操作是进行关键字间的比较，因此改进简单选择排序应从如何减少“比较”出发考虑。显然，在 $n$ 个关键字中选出最小值，至少进行 $n - 1$ 次比较，

然而，继续在剩余的 $n - 1$ 个关键字中选择次小值就并非一定要进行 $n - 2$ 次比较，若能利用前 $n - 1$ 次比较所得信息，则可减少以后各趙选择排序中所用的比较次数。实际上，体育比赛中的锦标赛便是一种选择排序。

> 例如，在 8 个运动员中决出前 3 名至多需要 11 场比赛，而不是 7 + 6 + 5 = 18 场比赛（它的前提是，若乙胜丙，甲胜乙，则认为甲必能胜丙）。

例如，图 10.8 (a）中最低层的叶子结点中 8 个选手之间经过第一轮的 4 场比赛之后选拔出 4 个优胜者“CHA”、“BAO”、“DIAO”和 WANG“”，然后经过两场半决赛和一场决赛之后，选拔出冠军“BAO”。显然，按照锦标赛的传递关系，亚军只能产生于分别在决赛，半决赛和第一轮比赛中输给冠军的选手中。由此，在经过 “CHA” 和 “LIU”、“CHA” 和 “DIAO” 的两场比赛之后，选拔出亚军 “CHA”，同理，选拔殿军的比赛只要在 “ZHAO” “LIU” 和 “DIAO” 3 个选手之间进行即可。按照这种锦标赛的思想可导出树形选择排序。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200804143913.png)
