
#### 标志算法的分析

##### 1. 各标志算法的比较

比较上述 3 种算法各有利弊。第 3 种算法在标志时不需要附加存储，使动态分配的可利用空间得到充分利用，但是由于在算法中，几乎是每个表结点的指针域的值都要作两次改变，因此时间上的开销相当大，而且，一且发生中断，整个系统瘫痪，无法重新启动运行。而非递归算法操作简单，时间上要比第 3 种算法省得多，然而它需要占有一定空间，使动态分配所用的存储量减少。

总之，无用单元收集是很费时间的，不能在实时处理的情况下应用。

通常，无用单元的收集工作是由编译程序中的专用系统来完成的，它也可以作为一个标准函数由用户自行调用（类似于 free 函数的使用）。不论哪一种情况，系统都要求用户建立一个初始变量表登录用户程序中所有链表的表头指针，以便从这些指针出发进行标志。

##### 2. 无用单元收集算法 的 定量估计

下面我们可以对无用单元收集算法作某种定量估计。如上所述，整个算法分两步进行：

1. 第一步对占用结点加标志，不管用哪一种算法，其所用时间都和结点数成正比。假设总的占用结点数为 $N$，则标志过程所需时间为 $c_1 N$（其中 c1 为某个常数）；
2. 第二步是从可用空间的第一个结点起，顺序扫描，将所有未加标志的结点链结在一起。假设可用空间总共含有 $M$ 个结点，则所需时间为 $c_2 M$（其中 c2 为某个常数）。

由此，收集算法总的时间为 $c_1 N + c_2 M$，同时收集到的无用结点个数为 $M - N$。

##### 3. 总结

显然，无用单元收集这项工作的效率和最后能收集到的可以重新分配的无用结点数有关。我们用收集一个无用结点所需的平均时间 $\left(c_{1} N+c_{2} M\right) /(M-N)$ 来度量这个效率。假设以 $\rho = N / M$ 表示内存使用的密度,则上述平均时间为 $\left(c_{1} \rho+c_{2}\right) /(1-\rho)$。当内存中 3 / 4 的结点为无用结点,即 $\rho = 1 / 4$ 时,收集一个结点所需平均时间为 $\left(c_{1} \rho+c_{2}\right) /(1-\rho)$，反之,当内存中 1 / 4 的结点为无用结点,即 $ \rho = 3 / 4$ 时，收集一个结点所需平均时间为 $3 c_1 + 4 c_2$。

由此可见，可利用内存区中只有少量的结点为无用结点时，收集无用单元的操作的效率很低。不仅如此，而且当系统重又恢复运行时，这些结点又很快被消耗掉，导致另一次无用单元的收集。如此下去有可能造成恶性循环，以至最后整个系统瘫痪。解决的办法可以由系统事先确定一个常数 $k$，当收集到的无用单元数为 $k$ 或更少时系统就不再运行下去。
