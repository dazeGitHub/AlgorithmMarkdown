
#### 1. 动态存储中的问题

以上 3 节讨论的问题都是如何利用可利用空间表来进行动态存储管理。

它的特点是：在用户请求存储时进行分配；在用户释放存储时进行回收，即系统是应用户的需求来进行存储分配和回收的。

因此，在这类存储管理系统中，用户必须明确给出“请求”和“释放”的信息。如在多用户分时并发的操作系统中，当用户程序进入系统时即请求分配存储区；反之，当用户程序执行完毕退出系统时即释放所占存储。又如，在使用 C 语言编写程序时，用户是通过 malloc 和 free 两个函数来表示请求分配和释放存储的。但有时会因为用户的疏漏或结构本身的原因致使系统在不恰当的时候或没有进行回收而产生“无用单元”或“悬挂访问”的问题。

##### 无用单元

“无用单元”是指那些用户不再使用而系统没有回收的结构和变量。例如下列 C 程序段

```cpp
p = malloc(size);

.
.
.

p = NULL;
```

执行的结果，是使执行 `p = malloc (size)` 为用户分配的结点成为无用单元，无法得到利用；

##### 悬挂访问

而下列程序段

```cpp
p = malloc(size);

.
.
.

q = p;

free(p);
```

执行的结果使指针变量 q 悬空，如果所释放的结点被再分配而继续访问指针 q 所指结点，则称这种访问为“悬挂访问”，并且由此引起的恶劣后果是可想而知的。

另一方面，由于结构本身的某些特性，也会产生同上类似问题。

例如在某用户程序中有 3 个广义表结构，如图 8.9 所示，$L_1$、$L_2$ 和 $L_3$ 分别为它们的表头指针，$L_4$ 是 $L_1$ 和 $L_2$ 共享的子表，$L_3$ 本身又为 $L_2$ 共享，则 $L_5$ 为 3 个广义表所共享。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200707172316.png)

在这种情况下，表结点的释放就成为一个问题。假设表 $L_1$ 不再使用，而表 $L_2$ 和 $L_3$ 尚在使用，若释放表 $L_1$, 即自 $L_1$ 指针起，顺链将所有结点回收到可利用空间表中（包括子表 L4 和 L。上所有结点），这就破坏了表 $L_2$ 和 $L_3$, 从而产生“悬挂访问”；反之，若不将表 $L_1$ 中结点释放，则当 $L_2$ 和 L』两个表也不被使用时，这些结点由于未曾“释放”无法被再分配而成为“无用单元”

#### 2. 解决方案

如何解决这个问题？有两条途径：

##### (1) 使用访问计数器

在所有子表或广义表上增加一个表头结点，并设立一个“计数域”，它的值为指向该子表或广义表的指针数目。只有当该计数域的值为零时，此子表或广义表中结点才被释放。

##### (2) 收集无用单元

在程序运行的过程中，对所有的链表结点，不管它是否还有用，都不回收，直到整个可利用空间表为空。此时才暂时中断执行程序，将所有当前不被使用的结点链接在一起，成为一个新的可利用空间表，而后程序再继续执行。显然，在一般情况下，是无法辨别哪些结点是当前未被使用的。然而，对于一个正在运行的程序，哪些结点正在使用是容易查明的，这只要从所有当前正在工作的指针变量出发，顺链遍历，那么，所有链结在这些链上的结点都是占用的。反之，可利用存储空间中的其余结点就都是无用的了。

由此，收集无用单元应分两步进行：

1. 第一步是对所有占用结点加上标志。回顾第 5 章的广义表的存储结构可在每个结点上再加设一个标志（mark）域，假设在无用单元收集之前所有结点的标志域均置为“0”，则加上标志就是将结点的标志域置为“1”；
2. 第二步是对整个可利用存储空间顺序扫描一遍，将所有标志域为“0”的结点链接成一个新的可利用空间表。

值得注意的是：上述第二步是容易进行的，而第一步是在极其困难的条件（即可利用存储几乎耗用殆尽）下进行的，因此，人们的精力主要集中在研究标志算法上。下面我们介绍 3 种标志算法（见 `标志算法.md`）
