
#### 标志算法

##### 1. 递归算法

从上面所述可知，加标志的操作实质上是遍历广义表，将广义表中所有结点的标志域赋值“1”。我们可写出遍历$(加标志)$算法的递归定义如下：

1. 若列表为空，则无需遍历；
2. 若是一个数据元素，则标志元素结点；
3. 反之，则列表非空，首先标志表结点；然后分别遍历表头和表尾。

这个算法很简单，易于用允许递归的高级语言描述之。但是，它需要一个较大的实现递归用的栈的辅助内存，这部分内存不能用于动态分配。并且，由于列表的层次不定，使得栈的容量不易确定，除非是在内存区中开辟一个相当大的区域留作栈，否则就有可能由于在标志过程中因栈的溢出而使系统瘫痪。

##### 2. 非递归算法

程序中附设栈$(或队列)$实现广义表的遍历。

从广义表的存储结构来看，表中有两种结点：

1. 一种是元素结点，结点中没有指针域；
2. 另一种是表结点，结点中包含两个指针域：表头指针和表尾指针，则它很类似于二叉树的二叉链表。列表中的元素结点相当于二叉树中的叶子结点，可以类似于遍历二叉树写出遍历表的非递归算法，只是在算法中应尽量减少栈的容量。

> 例如，类似于二叉树的前序遍历，对广义表则为：当表非空时，在对表结点加标志后，先顺表头指针逐层向下对表头加标志，同时将同层非空且未加标志的表尾指针依次入栈，直到表头为空表或为元素结点时停止，然后退栈取出上一层的表尾指针。反复上述进行过程，直到栈空为止。这个过程也可以称做深度优先搜索遍历。因为它和图的深度优先搜索遍历很相似。

显然，还可以类似于图的广度优先搜索遍历，对列表进行广度优先搜索遍历，或者说是对列表按层次遍历。同样，为实现这个遍历需附设一个队列$(这两个算法和二叉树或图的遍历极为相似，故在此不作详细描述，读者完全可以自己写出)$。在这两种非递归算法中，虽然附设的栈或队列的容量比递归算法中的栈的容量小，但和递归算法有同样的问题仍需要一个不确定量的附加存储，因此也不是理想的方法。

##### 3. 利用表结点本身的指针域标记遍历路径的算法

无论是在递归算法中还是在深度优先搜索的非递归算法中，不难看出，设栈的目的都是为了记下遍历时指针所走的路径，以便在遍历表头之后可以沿原路退回，继而对表尾进行遍历。如果我们能用别的方法记下指针所走路径，则可以免除附设栈。

在下面介绍的算法中就是利用已经标志过的表结点中的 tag、hp 和 tp 域来代替栈记录遍历过程中的路径。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200707174410.png)

例如：对图 8.10 中的广义表加标志。假设在递归算法中指针 p 指向刚加上标志的 b 结点，则：

$(1)$ 当指针 p 由 b 移向表头 c 之前需将 b 入$(此时 a 已在栈中)$;
$(2)$ 在表头标志之后需退栈，然后指针 p 在由 b 移向表尾 f 时需再次将 b 入栈；
$(3)$ 在 b 的表尾标志完之后应连续两次退栈，使 p 重又指向 a。与此对应，在本算法中不设栈。而是当指针 p 由 b 移向 c 之前，先将 b 结点中的 hp 域的值改为指向 a，并将 b 结点中的 tag 域的值改为“0”；而当指针 p 由 b 移向 f 之前，则先将 b 结点中的 tp 域的值改为指向 a, tag 域的值改为“1”。

###### 算法的基本思想

下面详细叙述算法的基本思想$(注：假设图 8.10 中的广义表 L'已加上标志)$。

算法中设定了 3 个互相关联的指针：当 p 指向某个表结点时；t 指向 p 的母表结点；q 指向 p 的表头或表尾。如图 8.11 中$(a)$和$(b)$所示

当 q 指向 p 的表头结点时，可能有 3 种情况出现：

$(1)$ 设 p 的表头只是一个元素结点，则遍历表头仅需对该表头结点打上标志后即令 q 指向 p 的表尾；
$(2)$ 设 p 的表头为空表或是已加上标志的子表，则无需遍历表头只要令 q 指向 p 的表尾即可；
$(3)$ 设 p 的表头为未加标志的子表，则需先遍历表头子表，即 p 应赋 q 的值，t 相应往下移动改赋 p 的值。为了记下 t 指针移动的路径，以便在 p 退回原结点时同时能找到 p 的母表结点$(即使 t 退回到原来的值)$，则在修改这个指针的值之前，应先记下 t 移动的路径，即令 p 所指结点的 hp 域的值为 t，且 tag 域的值为“0”。

另一方面，当 q 指向 p 的表尾时，也可能有两种情况出现：

$(1)$ p 的表尾为未加标志的子表，则需遍历表尾的子表，同样 p、t 指针要作相应的移动。为了记下当前表结点的母表结点，同样要在改动 p、t 指针的值之前先记下路径；即令 p 所指结点的 tp 域的值改为 t，然后令 t 赋值 p, P 赋值 q;
$(2)$ p 的表尾为“空”或是已加上标志的子表，此时表明 p 所指的表已加上标志，则 p 应退回到其母表结点即 t 所指结点，相应地也应后退一步，即退到 t 结点的母表结点。综上所述可知，t 的移动路径已记录在 t 结点的 hp 域或 tp 域中，究竟是哪一个？则要由辨别 tag 域的值来定。它不仅指示 t 应按哪个指针所指路径退回，而且指示了下一步应做什么。若 t 结点是其母表表头，则应继续遍历其母表的表尾。若 t 结点是其母表的表尾，则应继续找更高一层的母表结点。

###### 算法描述

整个算法大致描述如下：(GL 为广义表的头指针)$

```cpp
t = NULL; 
p = GL; 
finished = FALSE;

while(!finished){
    while(p -> mark == 0){
        p -> mark 1;
        MarkHead(p);                        //若表头是未经遍历的非空子表，则修改指针记录路径，
    }                                       //且 p 指向表头；否则 p 不变
    q = p -> p.tp;
    if(q && q -> mark == 0) 
        MarkTail(p);                        //修改指针记录路径，且 p 指向表尾 
    else 
        BackTrack(finished);                //若从表尾回溯到第一个结点，则 finished 为 TRUE
}
```

求精后的广义表遍历算法如算法 8.3 所示。

###### 算法 8.3

```cpp
void MarkList (GList GL){

    //遍历非空广义表 GL(GL != NULL 且 GL -> mark == 0)$，对表中所有未加标志的结点加标志。
    t = NUL; p = GL; finished = FALSE;      //t 指示 p 的母表

    while(!finished){
        while(p -> mark = 0){
            p -> mark = 1;
            //Markhead(p)$的细化
            q = p -> p.hp; //q 指向 *p 的表头 
            if(q && q -> mark == 0){
                if(q ->tag == 0) 
                    q -> mark = 1;          //ATOM，表头为原子结点
                else{
                    p -> p.hp = t; 
                    p -> tag = 0; 
                    t = p; 
                    p = q; 
                }//继续遍历子表
            }
        }//完成对表头的标志

        q = p -> p.tp;                      //q 指向 *p 的表尾

        if(q && q -> mark == 0){            // 继续遍历尾表
            p -> p.tp = t;
            t = p; 
            p = q;
        }else{                              // BackTrack(finished 的细化：
            while(t && tー> tag == 1){      //LIST，表结点，从表尾回溯
                q = t;
                t = q -> p.tp;
                q -> p.tp = p;
                p = q;
                p -> tag = 1;
            }
            if(!t)
                finished = TRUE;            //结東
            else{                           //从表头回湖
                q = t; 
                t = q -> p.hp; 
                q -> p.hp = p; 
                p = q; 
                p -> tag = 1;
            }                               //继续遍历表尾
        }// else

    }// while

}// MarkList
```

![](https://gitee.com/mayundaze/img_bed/raw/master/20200708113119.png)

图 8.11 展示对图 8.10 中的广义表进行遍历加标志时各指针的变化状况。

* $(a)$ 为算法 8.3 开始执行时的状态。
* $(b)$ 和 $(c)$ 为指针向表头方向移动并改变结点的 hp 域指针的情形。
* $(d)$ 表示当表头遍历完成将对表尾进行标志时的指针变化情况。
* $(e)$ 和 $(f)$ 读者可看到指针回溯的情形。

在此省略了继续遍历时的指针变化状况，有兴趣的读者可试之补充。
