
#### 概述

在前面各章的讨论中，对每一种数据结构虽都介绍了它们在内存储器中的映像，但只是借助高级语言中的变量说明加以描述，并没涉及具体的存储分配。而实际上，结构中的每个数据元素都占有一定的内存位置，在程序执行的过程中，数据元素的存取是通过对应的存储单元来进行的。在早期的计算机上，这个存储管理的工作是由程序员自己来完成的。在程序执行之前，首先需将用机器语言或汇编语言编写的程序输送到内存的某个固定区域上，并预先给变量和数据分配好对应的内存地址（绝对地址或相对地址）。在有了高级语言之后，程序员不需要直接和内存地址打交道，程序中使用的存储单元都由逻辑变量（标识符）来表示，它们对应的内存地址都是由编译程序在编译或执行时进行分配

另一方面，当计算机是被单个用户使用时，那么整个内存除操作系统占用一部分之外,都归这个用户的程序使用(如 PDP-11/03 的内存为32KB，系统占用 4KB，用户程序可用 28KB）。但在多用户分时并发系统中，多个用户程序共享一个内存区域，此时每个用户程序使用的内存就由操作系统来进行分配了。并且，在总的内存不够使用时，还可采用自动覆盖技术。

对操作系统和编译程序来说，存储管理都是一个复杂而又重要的问题。不同语言的编译程序和不同的操作系统可以采用不同的存储管理方法。它们采用的具体做法，读者将在后续课程一一编译原理和操作系统中学习。本课程仅就动态存储管理中涉及的一些基本技术进行讨论。

##### 1. 动态存储管理的基本问题

动态存储管理的基本问题是系统如何应用户提出的“请求”分配内存？又如何回收那些用户不再使用而“释放”的内存，以备新的“请求”产生时重新进行分配？提出请求的用户可能是进入系统的一个作业，也可能是程序执行过程中的一个动态变量。因此，在不同的动态存储管理系统中，请求分配的内存量大小不同。通常在编译程序中是一个或几个字，而在系统中则是几千、几万，甚至是几十万。然而，系统每次分配给用户（不论大小）都是一个地址连续的内存区。

##### 2. 占用块 & 空闲块

为了叙述方便起见，在下面的讨论中，将统称已分配给用户使用的地址连续的内存区为 **“占用块”**，称未曾分配的地址连续的内存区为 **“可利用空间块”** 或 **“空闲块”**。

显然，不管什么样的动态存储管理系统，在刚开工时，整个内存区是一个“空闲块”（在编译程序中称之为“堆”）。随着用户进入系统，先后提出存储请求，系统则依次进行分配。因此，在系统运行的初期，整个内存区基本上分隔成两大部分：低地址区包含若干占用块；高地址区（即分配后的剩余部分）是一个“空闲块”。

##### 3. 多用户的内存分配

![](https://gitee.com/mayundaze/img_bed/raw/master/20200706162840.png)

例如图 $8.1(a)$ 所示为依次给 8 个用户进行分配后的系统的内存状态。经过一段时间以后，有的用户运行结束，它所占用的内存区变成空闲块，这就使整个内存区呈现出占用块和空闲块犬牙交错的状态。如图 $8.1(b)$ 所示。

假如此时又有新的用户进入系统请求分配内存，那么，系统将如何做呢？

通常有两种做法：

1. 一种策略是系统继续从高地址的空闲块中进行分配，而不理会已分配给用户的内存区是否已空闲，直到分配无法进行（即剩余的空闲块不能满足分配的请求）时，系统才去回收所有用户不再使用的空闲块，并且重新组织内存，将所有空闲的内存区连接在一起成为一个大的空闲块。
2. 另ー种策略是用户ー旦运行结束，便将它所占内存区释放成为空闲块，同时，每当新的用户请求分配内存时，系统需要巡视整个内存区中所有空闲块，并从中找出一个“合适”的空闲块分配之。

由此，系统需建立一张记录所有空闲块的 **“可利用空间表”**，此表的结构可以是“目录表”，也可以是“链表”。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200706163304.png)

> 图中空白的就是空闲状态，带斜线的是占用状态

如图 $8.2$ 所示为某系统运行过程中的内存状态及其两种结构的可利用空间表。其中图 $8.2(b)$ 是目录表，表中每个表目包括 3 项信息：`初始地址`、`空闲块大小`和 `使用情况`。图 $8.2(c)$ 是链表，表中一个结点表示一个 `空闲块`，系统每次进行分配或回收即为在可利用空间表中删除或插入个结点。

下面将分别讨论利用不同策略进行动态存储管理的方法。