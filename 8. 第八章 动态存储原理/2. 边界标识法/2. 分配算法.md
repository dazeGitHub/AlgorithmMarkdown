
#### 分配算法

分配的算法比较简单，假设我们采用首次拟合法进行分配，则只要从表头指针 pav 所指结点起，在可利用空间表中进行査找，找到第一个容量不小于请求分配的存储量 $(n)$ 的空闲块时，即可进行分配。为了使整个系统更有效地运行，在边界标识法中还作了如下两条约定：

$(1)$ 假设找到的此块待分配的空闲块的容量为 m 个字（包括头部和底部），若每次分配只是从中分配 n 个字给用户，剩余 $m - n$ 个字大小的结点仍留在链表中，则在若干次分配之后，链表中会出现一些容量极小总也分配不出去的空闲块，这就大大减慢了分配（查找）的速度。弥补的办法是：选定一个适当的常量 e，当 $m - n \leq e$ 时，就将容量为 m 的空闲块整块分配给用户；反之，只分配其中 n 个字的内存块。同时，为了避免修改指针，约定将该结点中的高地址部分分配给用户。

$(2)$ 如果每次分配都从同一个结点开始查找的话，势必造成存储量小的结点密集在头指针 pav 所指结点附近，这同样会增加查询较大空闲块的时间。反之，如果每次分配从不同的结点开始进行查找，使分配后剩余的小块均匀地分布在链表中，则可避免上述弊病。实现的方法是，在每次分配之后，令指针 pav 指向刚进行过分配的结点的后继结点。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200707095552.png)

例如，图 8.6 (b）所示可利用空间表在进行分配之后的状态如图 8.6 (c）所示。

##### 代码实现

算法 8.1 是上述分配策略的算法描述。

###### 算法 8.1

```cpp
//若有不小于 n 的空闲块，则分配相应的存储块，并返回其首地址；否则返回 NULL。若分配后可利用空间表不空，则 pav 指向表中刚分配过的结点的后继结点
Space AllocBoundTag(Space & pav, int n){

    for(p = pav; p && p -> size < n && p -> rlink != pav; p = p -> rlink);  //査找不小于 n 的空闲块 
    
    if (!p !! p -> size < n) 
        return NULL;                                                        //找不到，返回空指针
    else{                                                                   //p 指向找到的空闲块
        f = FootLoc(p);                                                     //指向底部
        pav = p -> rlink;                                                   //pav 指向 * p 结点的后继结点。
        if(p -> size - n <= e){                                             //整块分配，不保留 <= e 的剩余量
            if(pav == p) 
                pav = NULL;                                                 //可利用空间表变为空表
            else{                                                           //在表中删除分配的结点
                pav -> llink = p -> llink; 
                p -> link -> rlink = pav;
            }//if
            p -> tag = f -> tag = 1;                                        //修改分配结点的头部和底部标志
        }//if
        else{
            f -> tag = 1;                                                   //修改分配块的底部标志 
            p -> size -= n;                                                 //置剩余块大小 
            f = FootLoc(p);                                                 //指向剩余块底部 
            f -> tag = 0; 
            f -> uplink = p;                                                //设置剩余块底部
            p = f + 1;                                                      //指向分配块头部 
            p -> tag = 1;                                                   //设置分配块头部
            p -> size = n;  
        }
        return p;                                                           //返回分配块首地址 
    }//else 
}//AllocBoundTag
```