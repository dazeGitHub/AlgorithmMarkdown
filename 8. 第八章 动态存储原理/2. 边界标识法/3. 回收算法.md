
#### 回收算法

一旦用户释放占用块，系统需立即回收以备新的请求产生时进行再分配。为了使物理地址毗邻的空闲块结合成一个尽可能大的结点，则首先需要检査刚释放的占用块的左、右紧邻是否为空闲块。由于本系统在每个内存区（无论是占用块或空闲块）的边界上都设有标志值，则很容易辨明这一点。

##### 辨别左右紧邻的内存块是否空闲

假设用户释放的内存区的头部地址为 p，则与其低地址紧邻的内存区的底部地址为 $p - 1$; 与其高地址紧邻的内存区的头部地址为 $p + p \rightarrow size$，它们中的标志域就表明了这两个邻区的使用状况：

1. 若 $(p - 1) \rightarrow tag = 0$; 则表明其左邻为空闲块；
2. 若 $(p + p \rightarrow size) \rightarrow tag = 0$; 则表明其右邻为空闲块。

##### 左右是空闲块的处理

若释放块的左、右邻区均为占用块，则处理最为简单，只要将此新的空闲块作为一个结点插人到可利用空闲表中即可；若只有左部区是空闲块，则应与左邻区合并成一个结点；若只有右邻区是空闲块，则应与右部区合并成一个结点；若左、右邻区都是空闲块，则应将 3 块合起来成为一个结点留在可利用空间表中。

下面我们就这 4 种情况分别描述它们的算法：

$(1)$ 释放块的左、右邻区均为占用块。此时只要作简单插人即可。由于边界标识法在按首次拟合进行分配时对可利用空间表的结构没有任何要求，则新的空闲块插人在表中任何位置均可。简单的做法就是插人在 pav 指针所指结点之前（或之后），可描述如下

```cpp
p -> tag = 0; 
FootLoc(p) -> uplink = p; 
FootLoc(p) -> tag = 0; 
if(!pav) 
    pav = p-> llink = p-> rlink = p;
else{
    q = pav -> llink;
    p -> rlink = pav; 
    p -> llink = q;
    q -> rlink = pav -> llink = p;
    pav = p;                                //令刚释放的结点为下次分配时的最先查询的结点
}
```

$(2)$ 释放块的左邻区为空闲块，而右邻区为占用块。由于释放块的头部和左邻空闲块的底部眦邻，因此只要改变左邻空闲块的结点：增加结点的 size 域的值且重新设置结点的底部即可。描述如下

```cpp
n = p -> size;                              //释放块的大小 
s = (p - 1) -> uplink;                      //左邻空闲块的头部地址
s -> size += n;                             //设置新的空闲块大小 
f = p + n - 1; 
f -> uplink = s; 
f -> tag = 0;                               //设置新的空闲块底部
```

$(3)$ 释放块的右邻区为空闲块，而左邻区为占用块。由于释放块的底部和右邻空闲块的头部毗邻，因此，当表中结点由原来的右邻空闲块变成合并后的大空闲块时，结点的底部位置不变，但头部要变，由此，链表中的指针也要变。描述如下：

```cpp
t = p + p -> size;                          //右邻空闲块的头部地址
p -> tag = 0;                               //p 为合并后的结点头部地址
q = t -> llink                              //q 为 *t 结点在可利用空间表中的前驱结点的头部地址 
p -> llink = q; q -> rlink = p;             //q 指向 *p 的前驱 
ql = t -> rlink;                            //ql 为 *t 结点在可利用空间表中的后继结点的头部地址 
p -> rlink = ql; ql -> llink = p;           //ql 指向 *p 的后继 
p -> size + = t -> size;                    //新的空闲块的大小 
FootLoc(t) -> uplink = p;                   //底部指针指向新结点的头部
```

$(4)$ 释放块的左、右邻区均为空闲块。为使 3 个空闲块连接在一起成为一个大结点留在可利用空间表中，只要增加左邻空闲块的 space 容量，同时在链表中删去右邻空闲块结点即可。所作改变可描述如下：

```cpp
n = p -> size;                              //释放块的大小 
s = (p - 1) -> uplink;                      //指向左邻块
t = p + p -> size;                          //指向右邻块 
s -> size + = n + t -> size;                //设置新结点的大小 
q = t -> llink; ql = t -> rlink;            //q != ql
q -> rlink = ql; ql -> link = q;            //删去右邻空闲块结点 
FootLoc(t) -> uplink = s;                   //新结点底部指针指向其头部
```

总之，边界标识法由于在每个结点的头部和底部设立了标识域，使得在回收用户释放的内存块时，很容易判别与它毗邻的内存区是否是空闲块，且不需要查询整个可利用空间表便能找到毗邻的空闲块与其合并之；再者，由于可利用空间表上结点既不需依结点大小
有序，也不需依结点地址有序，则释放块插入时也不需查找链表。由此，不管是哪一种情况，回收空闲块的时间都是个常量，和可利用空间表的大小无关。惟一的缺点是增加了结点底部所占的存储量

在上述后 3 种情况下，可利用空间表的变化如图 8.7 所示。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200707111010.png)

![](https://gitee.com/mayundaze/img_bed/raw/master/20200707111210.png)
