
#### 回收算法

在用户释放不再使用的占用块时，系统需将这新的空闲块插入到可利用空间表中去。这里，同样有一个地址相邻的空闲块归并成大块的问题。但是在伙伴系统中仅考虑互为“伙伴”的两个空闲块的归并。

何谓“伙伴”? 如前所述，在分配时经常需要将一个大的空闲块分裂成两个大小相等的存储区，**这两个由同一大块分裂出来的小块就称之“互为伙伴”**。

例如：假设 $p$ 为大小为 $2^k$ 的空闲块的初始地址，且 $p \;\mathrm{MOD}\; 2^{k + 1} = 0$, 则初始地址为 $p$ 和 $p + 2$ 的两个空闲块互为伙伴。在伙伴系统中回收空闲块时，只当其伙伴为空闲块时才归并成大块。也就是说，若有两个空闲块，即使大小相同且地址相邻，但不是由同一大块分裂出来的，也不归并在一起。例如图中的 A、B 两个空闲块不是伙伴。

![](https://gitee.com/mayundaze/img_bed/raw/master/20200707161905.png)

由此，在回收空闲块时，应首先判别其伙伴是否为空闲块，若否，则只要将释放的空闲块简单插人在相应子表中即可；若是，则需在相应子表中找到其伙伴并删除之，然后再判别合并后的空闲块的伙伴是否是空闲块。依此重复，直到归并所得空闲块的伙伴不是空闲块时，再插人到相应的子表中去。

起始地址为 p，大小为 $2^k$ 的内存块，其伙伴块的起始地址为：

$\qquad buddy(p,k) = \left\{\begin{array}{l}p + 2^{k} \qquad (若 p \; MOD \; 2^{k + 1} = 0)\\\\ p - 2^{k} \qquad  (若 p \; MOD \; 2^{k + 1} = 2^k)\qquad  \end{array}\right.$

例如，假设整个可利用内存区大小为 $2^{10} = 1024$（地址从 0 到 1023），则大小为 $2^8$, 起始地址为 512 的伙伴块的起始地址为 768; 大小为 $2^7$, 起始地址为 384 的伙伴块的起始地址为 256

整个释放算法在此不再详细列出，请读者自行补充。

总之，伙伴系统的优点是算法简单、速度快；缺点是由于只归并伙伴而容易产生碎片。
